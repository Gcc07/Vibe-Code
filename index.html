<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Psychedelic Racer 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            perspective: 800px;
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            transform-style: preserve-3d;
            transform: rotateX(30deg) rotateY(0deg);
            transition: transform 0.1s;
        }

        #gameCanvas {
            border: 2px solid #fff;
            background: #000;
            transform-style: preserve-3d;
            transform: translateZ(0);
            box-shadow: 0 0 50px rgba(255, 0, 255, 0.5);
            display: block;
        }

        #gameOver {
            position: absolute;
            color: #fff;
            font-size: 48px;
            text-align: center;
            display: none;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffff;
            transform: translateZ(200px);
            animation: pulse 2s infinite;
            width: 100%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(200px);
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) translateZ(200px) scale(1); }
            50% { transform: translate(-50%, -50%) translateZ(200px) scale(1.1); }
            100% { transform: translate(-50%, -50%) translateZ(200px) scale(1); }
        }

        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 24px;
            text-shadow: 0 0 5px #ff00ff, 0 0 10px #00ffff;
            transform: translateZ(200px);
            z-index: 10;
        }

        #startScreen {
            position: absolute;
            color: #fff;
            text-align: center;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffff;
            transform: translateZ(200px);
            width: 100%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(200px);
        }

        #startButton {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            transform: translateZ(200px);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        #startButton:hover {
            transform: translateZ(200px) scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }

        .road-line {
            position: absolute;
            background: #fff;
            width: 10px;
            height: 50px;
            transform-style: preserve-3d;
            box-shadow: 0 0 10px #fff;
        }

        #pauseMenu {
            position: absolute;
            color: #fff;
            text-align: center;
            display: none;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffff;
            width: 100%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(200px);
            z-index: 20;
            filter: none !important;
        }

        #resumeButton {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            transform: translateZ(200px);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        #resumeButton:hover {
            transform: translateZ(200px) scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }

        .blur {
            filter: blur(5px);
        }

        #gameCanvas.blur {
            filter: blur(5px);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="score">Score: 0</div>
        <div id="gameOver">GAME OVER<br>Press R to restart</div>
        <div id="startScreen">
            <h1>PSYCHEDELIC RACER 3D</h1>
            <p>Use arrow keys or WASD to move</p>
            <button id="startButton">START GAME</button>
        </div>
        <div id="pauseMenu">
            <h1>PAUSED</h1>
            <p>Press ESC to resume</p>
            <button id="resumeButton">RESUME</button>
        </div>
    </div>

    <script>
        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const gameOverScreen = document.getElementById('gameOver');
            const scoreElement = document.getElementById('score');
            const startScreen = document.getElementById('startScreen');
            const startButton = document.getElementById('startButton');
            const gameContainer = document.getElementById('gameContainer');
            const pauseMenu = document.getElementById('pauseMenu');
            const resumeButton = document.getElementById('resumeButton');

            // Set canvas size
            canvas.width = 800;
            canvas.height = 600;

            // Game variables
            let gameStarted = false;
            let gameOver = false;
            let score = 0;
            let animationFrame;
            let hue = 0;
            let roadLines = [];
            let tilt = 0;
            let isPaused = false;

            // Player car
            const car = {
                x: canvas.width / 2,
                y: canvas.height - 100,
                width: 50,
                height: 80,
                speed: 8,
                z: 0,
                velocity: 0,
                rotation: 0,
                drift: false,
                driftAngle: 0,
                driftPower: 0
            };

            // Track segments
            const trackSegments = [];
            const segmentHeight = 50;
            const trackWidth = 300;
            let trackOffset = 0;
            const maxSegments = Math.ceil(canvas.height / segmentHeight) + 2;

            // Obstacles
            const obstacles = [];
            const obstacleWidth = 50;
            const obstacleHeight = 50;

            // Initialize track
            function initTrack() {
                trackSegments.length = 0;
                for (let i = 0; i < maxSegments; i++) {
                    trackSegments.push({
                        y: i * segmentHeight,
                        offset: Math.sin(i * 0.5) * 50, // Smoother initial curve
                        z: i * 20,
                        hue: (hue + i * 30) % 360
                    });
                }
            }

            // Create new obstacle
            function createObstacle() {
                obstacles.push({
                    x: Math.random() * (canvas.width - obstacleWidth),
                    y: -obstacleHeight,
                    width: obstacleWidth,
                    height: obstacleHeight,
                    z: 0,
                    hue: (hue + Math.random() * 360) % 360
                });
            }

            // Update game state
            function update() {
                if (gameOver || isPaused) return;
                
                // Update segment positions and properties
                trackSegments.forEach(segment => {
                    segment.y += 4;
                    segment.hue = (segment.hue + 0.5) % 360;
                    
                    // Smoothly update offset using a continuous sine wave
                    const targetOffset = Math.sin((segment.y) / 100) * 50;
                    segment.offset += (targetOffset - segment.offset) * 0.1;
                    
                    // Reset segment position when it goes off screen
                    if (segment.y > canvas.height) {
                        segment.y = -segmentHeight;
                        segment.z = 0;
                        // Maintain smooth curve by using the last segment's offset as reference
                        const lastSegment = trackSegments[trackSegments.length - 1];
                        segment.offset = lastSegment.offset;
                        segment.hue = (lastSegment.hue + 30) % 360;
                    }
                });

                // Move obstacles
                obstacles.forEach(obstacle => {
                    obstacle.y += 6;
                    obstacle.z += 0.4;
                    obstacle.hue = (obstacle.hue + 1) % 360;
                });

                // Remove off-screen obstacles
                obstacles.forEach((obstacle, index) => {
                    if (obstacle.y > canvas.height) {
                        obstacles.splice(index, 1);
                        score += 10;
                        scoreElement.textContent = `Score: ${score}`;
                    }
                });

                // Create new obstacles
                if (Math.random() < 0.02) {
                    createObstacle();
                }

                // Update container tilt based on car position
                const targetTilt = ((car.x - canvas.width/2) / (canvas.width/2)) * 10;
                tilt += (targetTilt - tilt) * 0.1;
                gameContainer.style.transform = `rotateX(30deg) rotateY(${tilt}deg)`;

                // Check collisions
                if (checkCollisions()) {
                    gameOver = true;
                    gameOverScreen.style.display = 'block';
                }
            }

            // Draw everything
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
                drawTrack();
                drawObstacles();
                drawCar();
            }

            // Draw psychedelic background
            function drawBackground() {
                hue = (hue + 0.2) % 360; // Slower color transition
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 0.3)`); // More transparent
                gradient.addColorStop(0.5, `hsla(${(hue + 120) % 360}, 100%, 50%, 0.2)`);
                gradient.addColorStop(1, `hsla(${(hue + 240) % 360}, 100%, 50%, 0.3)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Add subtle noise effect instead of large circles
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const size = Math.random() * 2 + 1; // Very small dots
                    const opacity = Math.random() * 0.1; // Very subtle
                    
                    ctx.fillStyle = `hsla(${(hue + i * 3.6) % 360}, 100%, 50%, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw track with 3D effect
            function drawTrack() {
                // Draw segments that are visible on screen
                trackSegments.forEach(segment => {
                    const y = segment.y;
                    if (y < -segmentHeight || y > canvas.height) return; // Skip off-screen segments
                    
                    const x = canvas.width / 2 + segment.offset - trackWidth / 2;
                    const scale = 1 + (segment.z / 800);
                    const tilt = Math.sin(y / 50) * 10;
                    
                    ctx.save();
                    ctx.translate(x + trackWidth/2, y + segmentHeight/2);
                    ctx.scale(scale, scale);
                    ctx.rotate(tilt * Math.PI / 180);
                    ctx.translate(-(x + trackWidth/2), -(y + segmentHeight/2));
                    
                    // Draw track base with gradient
                    const trackGradient = ctx.createLinearGradient(x, y, x, y + segmentHeight);
                    trackGradient.addColorStop(0, `hsla(${segment.hue}, 100%, 20%, 0.8)`);
                    trackGradient.addColorStop(0.5, `hsla(${(segment.hue + 60) % 360}, 100%, 30%, 0.8)`);
                    trackGradient.addColorStop(1, `hsla(${segment.hue}, 100%, 20%, 0.8)`);
                    ctx.fillStyle = trackGradient;
                    ctx.fillRect(x, y, trackWidth, segmentHeight);
                    
                    // Draw track borders with glow
                    ctx.shadowColor = `hsl(${segment.hue}, 100%, 50%)`;
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = `hsl(${segment.hue}, 100%, 70%)`;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, trackWidth, segmentHeight);
                    
                    // Draw center line with animation
                    const centerLineWidth = 5;
                    const centerLineOffset = Math.sin((y + trackOffset) / 20) * 10;
                    ctx.fillStyle = `hsl(${(segment.hue + 120) % 360}, 100%, 70%)`;
                    ctx.shadowColor = `hsl(${(segment.hue + 120) % 360}, 100%, 50%)`;
                    ctx.shadowBlur = 10;
                    ctx.fillRect(
                        x + trackWidth/2 - centerLineWidth/2 + centerLineOffset,
                        y,
                        centerLineWidth,
                        segmentHeight
                    );
                    
                    // Draw side lines with animation
                    const sideLineWidth = 3;
                    const sideLineOffset = Math.sin((y + trackOffset) / 30) * 5;
                    ctx.fillStyle = `hsl(${(segment.hue + 180) % 360}, 100%, 70%)`;
                    ctx.shadowColor = `hsl(${(segment.hue + 180) % 360}, 100%, 50%)`;
                    ctx.shadowBlur = 8;
                    
                    // Left side line
                    ctx.fillRect(
                        x + trackWidth/4 - sideLineWidth/2 + sideLineOffset,
                        y,
                        sideLineWidth,
                        segmentHeight
                    );
                    
                    // Right side line
                    ctx.fillRect(
                        x + trackWidth*3/4 - sideLineWidth/2 - sideLineOffset,
                        y,
                        sideLineWidth,
                        segmentHeight
                    );
                    
                    // Draw grid pattern
                    ctx.strokeStyle = `hsla(${(segment.hue + 240) % 360}, 100%, 50%, 0.3)`;
                    ctx.lineWidth = 1;
                    const gridSize = 20;
                    for (let i = 0; i < trackWidth; i += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(x + i, y);
                        ctx.lineTo(x + i, y + segmentHeight);
                        ctx.stroke();
                    }
                    for (let i = 0; i < segmentHeight; i += gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(x, y + i);
                        ctx.lineTo(x + trackWidth, y + i);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                });
            }

            // Draw car with 3D effect
            function drawCar() {
                const scale = 1 + (car.z / 800);
                const tilt = Math.sin(Date.now() / 200) * 5;
                
                ctx.save();
                ctx.translate(car.x, car.y);
                ctx.scale(scale, scale);
                ctx.rotate((tilt + car.driftAngle) * Math.PI / 180);
                ctx.translate(-car.x, -car.y);
                
                // Main body with advanced gradient
                const carGradient = ctx.createLinearGradient(
                    car.x - car.width/2,
                    car.y - car.height/2,
                    car.x + car.width/2,
                    car.y + car.height/2
                );
                carGradient.addColorStop(0, `hsl(${hue}, 100%, 60%)`);
                carGradient.addColorStop(0.3, `hsl(${(hue + 180) % 360}, 100%, 40%)`);
                carGradient.addColorStop(0.7, `hsl(${(hue + 180) % 360}, 100%, 40%)`);
                carGradient.addColorStop(1, `hsl(${hue}, 100%, 60%)`);
                
                // Draw main body with sleek design
                ctx.fillStyle = carGradient;
                ctx.beginPath();
                // Front
                ctx.moveTo(car.x - car.width/2, car.y - car.height/4);
                ctx.quadraticCurveTo(
                    car.x - car.width/3, car.y - car.height/2,
                    car.x - car.width/4, car.y - car.height/2
                );
                ctx.quadraticCurveTo(
                    car.x, car.y - car.height/2.2,
                    car.x + car.width/4, car.y - car.height/2
                );
                ctx.quadraticCurveTo(
                    car.x + car.width/3, car.y - car.height/2,
                    car.x + car.width/2, car.y - car.height/4
                );
                // Back
                ctx.quadraticCurveTo(
                    car.x + car.width/2.5, car.y + car.height/2,
                    car.x + car.width/3, car.y + car.height/2
                );
                ctx.quadraticCurveTo(
                    car.x, car.y + car.height/1.8,
                    car.x - car.width/3, car.y + car.height/2
                );
                ctx.quadraticCurveTo(
                    car.x - car.width/2.5, car.y + car.height/2,
                    car.x - car.width/2, car.y - car.height/4
                );
                ctx.closePath();
                ctx.fill();
                
                // Add glowing outline
                ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
                ctx.shadowBlur = 20;
                ctx.strokeStyle = `hsl(${hue}, 100%, 80%)`;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Cockpit with advanced design
                const cockpitGradient = ctx.createLinearGradient(
                    car.x - car.width/3, car.y - car.height/3,
                    car.x + car.width/3, car.y - car.height/3
                );
                cockpitGradient.addColorStop(0, `hsla(${(hue + 120) % 360}, 100%, 70%, 0.4)`);
                cockpitGradient.addColorStop(0.5, `hsla(${(hue + 120) % 360}, 100%, 90%, 0.6)`);
                cockpitGradient.addColorStop(1, `hsla(${(hue + 120) % 360}, 100%, 70%, 0.4)`);
                
                ctx.fillStyle = cockpitGradient;
                ctx.beginPath();
                ctx.moveTo(car.x - car.width/3, car.y - car.height/3);
                ctx.quadraticCurveTo(
                    car.x, car.y - car.height/2.5,
                    car.x + car.width/3, car.y - car.height/3
                );
                ctx.quadraticCurveTo(
                    car.x + car.width/4, car.y - car.height/4,
                    car.x - car.width/4, car.y - car.height/4
                );
                ctx.quadraticCurveTo(
                    car.x - car.width/3, car.y - car.height/3,
                    car.x - car.width/3, car.y - car.height/3
                );
                ctx.closePath();
                ctx.fill();
                
                // Engine section with pulsing effect
                const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8;
                const engineGradient = ctx.createLinearGradient(
                    car.x - car.width/3, car.y + car.height/3,
                    car.x + car.width/3, car.y + car.height/3
                );
                engineGradient.addColorStop(0, `hsla(${(hue + 60) % 360}, 100%, 50%, ${pulse})`);
                engineGradient.addColorStop(0.5, `hsla(${(hue + 60) % 360}, 100%, 70%, ${pulse})`);
                engineGradient.addColorStop(1, `hsla(${(hue + 60) % 360}, 100%, 50%, ${pulse})`);
                
                ctx.fillStyle = engineGradient;
                ctx.beginPath();
                ctx.moveTo(car.x - car.width/3, car.y + car.height/3);
                ctx.quadraticCurveTo(
                    car.x, car.y + car.height/2.5,
                    car.x + car.width/3, car.y + car.height/3
                );
                ctx.quadraticCurveTo(
                    car.x + car.width/4, car.y + car.height/2,
                    car.x - car.width/4, car.y + car.height/2
                );
                ctx.quadraticCurveTo(
                    car.x - car.width/3, car.y + car.height/3,
                    car.x - car.width/3, car.y + car.height/3
                );
                ctx.closePath();
                ctx.fill();
                
                // Side details with glowing lines
                ctx.strokeStyle = `hsl(${(hue + 180) % 360}, 100%, 70%)`;
                ctx.lineWidth = 2;
                ctx.shadowColor = `hsl(${(hue + 180) % 360}, 100%, 50%)`;
                ctx.shadowBlur = 10;
                
                // Left side detail
                ctx.beginPath();
                ctx.moveTo(car.x - car.width/2, car.y - car.height/4);
                ctx.quadraticCurveTo(
                    car.x - car.width/2.5, car.y,
                    car.x - car.width/3, car.y
                );
                ctx.stroke();
                
                // Right side detail
                ctx.beginPath();
                ctx.moveTo(car.x + car.width/3, car.y);
                ctx.quadraticCurveTo(
                    car.x + car.width/2.5, car.y,
                    car.x + car.width/2, car.y - car.height/4
                );
                ctx.stroke();
                
                // Front lights with advanced glow
                const lightPulse = Math.sin(Date.now() / 50) * 0.2 + 0.8;
                ctx.fillStyle = `hsla(${(hue + 120) % 360}, 100%, 90%, ${lightPulse})`;
                ctx.shadowColor = `hsla(${(hue + 120) % 360}, 100%, 70%, ${lightPulse})`;
                ctx.shadowBlur = 15;
                
                // Left headlight
                ctx.beginPath();
                ctx.arc(car.x - car.width/3, car.y - car.height/3, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Right headlight
                ctx.beginPath();
                ctx.arc(car.x + car.width/3, car.y - car.height/3, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Add energy trails
                const trailGradient = ctx.createLinearGradient(
                    car.x - car.width/2, car.y + car.height/2,
                    car.x - car.width/2, car.y + car.height/2 + 20
                );
                trailGradient.addColorStop(0, `hsla(${(hue + 60) % 360}, 100%, 70%, 0.8)`);
                trailGradient.addColorStop(1, `hsla(${(hue + 60) % 360}, 100%, 70%, 0)`);
                
                ctx.fillStyle = trailGradient;
                ctx.beginPath();
                ctx.moveTo(car.x - car.width/3, car.y + car.height/2);
                ctx.lineTo(car.x + car.width/3, car.y + car.height/2);
                ctx.lineTo(car.x, car.y + car.height/2 + 20);
                ctx.closePath();
                ctx.fill();
                
                // Add drift effects
                if (car.drift) {
                    // Drift smoke
                    const driftIntensity = Math.abs(car.velocity) / 10;
                    for (let i = 0; i < 3; i++) {
                        const smokeX = car.x + (Math.random() - 0.5) * 20;
                        const smokeY = car.y - car.height/2 - Math.random() * 20;
                        const smokeSize = Math.random() * 10 + 5;
                        const smokeOpacity = Math.random() * 0.3 + 0.1;
                        
                        ctx.fillStyle = `hsla(${(hue + 180) % 360}, 100%, 50%, ${smokeOpacity})`;
                        ctx.shadowColor = `hsla(${(hue + 180) % 360}, 100%, 50%, ${smokeOpacity})`;
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Drift trail
                    const trailGradient = ctx.createLinearGradient(
                        car.x - car.width/2, car.y - car.height/2,
                        car.x - car.width/2, car.y - car.height/2 - 30
                    );
                    trailGradient.addColorStop(0, `hsla(${(hue + 60) % 360}, 100%, 70%, ${driftIntensity})`);
                    trailGradient.addColorStop(1, `hsla(${(hue + 60) % 360}, 100%, 70%, 0)`);
                    
                    ctx.fillStyle = trailGradient;
                    ctx.beginPath();
                    ctx.moveTo(car.x - car.width/3, car.y - car.height/2);
                    ctx.lineTo(car.x + car.width/3, car.y - car.height/2);
                    ctx.lineTo(car.x, car.y - car.height/2 - 30);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }

            // Draw obstacles with 3D effect
            function drawObstacles() {
                obstacles.forEach(obstacle => {
                    const scale = 1 + (obstacle.z / 800);
                    const tilt = Math.sin(Date.now() / 300 + obstacle.x) * 5;
                    
                    ctx.save();
                    ctx.translate(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
                    ctx.scale(scale, scale);
                    ctx.rotate(tilt * Math.PI / 180);
                    ctx.translate(-(obstacle.x + obstacle.width/2), -(obstacle.y + obstacle.height/2));
                    
                    // Draw building base with gradient
                    const buildingGradient = ctx.createLinearGradient(
                        obstacle.x,
                        obstacle.y,
                        obstacle.x,
                        obstacle.y + obstacle.height
                    );
                    buildingGradient.addColorStop(0, `hsl(${obstacle.hue}, 100%, 30%)`);
                    buildingGradient.addColorStop(0.5, `hsl(${(obstacle.hue + 60) % 360}, 100%, 20%)`);
                    buildingGradient.addColorStop(1, `hsl(${obstacle.hue}, 100%, 10%)`);
                    ctx.fillStyle = buildingGradient;
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Add building details
                    const windowSize = 8;
                    const windowSpacing = 12;
                    const windowRows = Math.floor(obstacle.height / windowSpacing);
                    const windowCols = Math.floor(obstacle.width / windowSpacing);
                    
                    // Draw windows
                    for (let row = 0; row < windowRows; row++) {
                        for (let col = 0; col < windowCols; col++) {
                            const windowX = obstacle.x + col * windowSpacing + (windowSpacing - windowSize) / 2;
                            const windowY = obstacle.y + row * windowSpacing + (windowSpacing - windowSize) / 2;
                            
                            // Random window glow
                            const glowIntensity = Math.random() * 0.8 + 0.2;
                            ctx.fillStyle = `hsla(${(obstacle.hue + 120) % 360}, 100%, 70%, ${glowIntensity})`;
                            ctx.shadowColor = `hsla(${(obstacle.hue + 120) % 360}, 100%, 50%, ${glowIntensity})`;
                            ctx.shadowBlur = 5;
                            ctx.fillRect(windowX, windowY, windowSize, windowSize);
                        }
                    }
                    
                    // Add building edges with glow
                    ctx.shadowColor = `hsl(${obstacle.hue}, 100%, 50%)`;
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = `hsl(${obstacle.hue}, 100%, 70%)`;
                    ctx.lineWidth = 2;
                    
                    // Draw vertical edges
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x, obstacle.y);
                    ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
                    ctx.moveTo(obstacle.x + obstacle.width, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                    ctx.stroke();
                    
                    // Draw horizontal edges
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y);
                    ctx.moveTo(obstacle.x, obstacle.y + obstacle.height);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                    ctx.stroke();
                    
                    // Add architectural details
                    const detailSpacing = obstacle.height / 4;
                    for (let i = 1; i < 4; i++) {
                        const detailY = obstacle.y + i * detailSpacing;
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, detailY);
                        ctx.lineTo(obstacle.x + obstacle.width, detailY);
                        ctx.strokeStyle = `hsla(${(obstacle.hue + 180) % 360}, 100%, 50%, 0.5)`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    
                    // Add antenna/spire
                    const spireHeight = obstacle.height * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width/2, obstacle.y - spireHeight);
                    ctx.strokeStyle = `hsl(${(obstacle.hue + 60) % 360}, 100%, 70%)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add spire glow
                    ctx.fillStyle = `hsl(${(obstacle.hue + 60) % 360}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(obstacle.x + obstacle.width/2, obstacle.y - spireHeight, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                });
            }

            // Check collisions
            function checkCollisions() {
                return obstacles.some(obstacle => {
                    return car.x + car.width / 2 > obstacle.x &&
                           car.x - car.width / 2 < obstacle.x + obstacle.width &&
                           car.y + car.height / 2 > obstacle.y &&
                           car.y - car.height / 2 < obstacle.y + obstacle.height;
                });
            }

            // Game loop
            function gameLoop() {
                if (!isPaused) {
                    update();
                }
                draw();
                animationFrame = requestAnimationFrame(gameLoop);
            }

            // Handle keyboard input
            const keys = {};
            window.addEventListener('keydown', e => {
                keys[e.key] = true;
                if (gameOver && e.key === 'r') {
                    resetGame();
                }
                if (e.key === 'Escape' && gameStarted && !gameOver) {
                    togglePause();
                }
            });
            window.addEventListener('keyup', e => {
                keys[e.key] = false;
            });

            // Update car position based on input
            function handleInput() {
                const maxVelocity = 10;
                const acceleration = 0.5;
                const deceleration = 0.3;
                const driftThreshold = 0.5;
                const maxDriftAngle = 30;

                // Handle left/right movement
                if (keys['ArrowLeft'] || keys['a']) {
                    car.velocity = Math.max(-maxVelocity, car.velocity - acceleration);
                    if (Math.abs(car.velocity) > driftThreshold) {
                        car.drift = true;
                        car.driftAngle = Math.min(maxDriftAngle, car.driftAngle + 2);
                    }
                } else if (keys['ArrowRight'] || keys['d']) {
                    car.velocity = Math.min(maxVelocity, car.velocity + acceleration);
                    if (Math.abs(car.velocity) > driftThreshold) {
                        car.drift = true;
                        car.driftAngle = Math.max(-maxDriftAngle, car.driftAngle - 2);
                    }
                } else {
                    // Decelerate when no input
                    if (car.velocity > 0) {
                        car.velocity = Math.max(0, car.velocity - deceleration);
                    } else if (car.velocity < 0) {
                        car.velocity = Math.min(0, car.velocity + deceleration);
                    }
                    
                    // Reduce drift angle when not actively drifting
                    if (Math.abs(car.driftAngle) > 0) {
                        car.driftAngle *= 0.95;
                        if (Math.abs(car.driftAngle) < 0.1) {
                            car.driftAngle = 0;
                            car.drift = false;
                        }
                    }
                }

                // Update car position with momentum
                car.x += car.velocity;
                car.x = Math.max(car.width / 2, Math.min(canvas.width - car.width / 2, car.x));
            }

            // Toggle pause state
            function togglePause() {
                isPaused = !isPaused;
                if (isPaused) {
                    pauseMenu.style.display = 'block';
                    canvas.classList.add('blur');
                } else {
                    pauseMenu.style.display = 'none';
                    canvas.classList.remove('blur');
                }
            }

            // Resume button click handler
            resumeButton.addEventListener('click', () => {
                togglePause();
            });

            // Reset game
            function resetGame() {
                gameOver = false;
                isPaused = false;
                score = 0;
                scoreElement.textContent = `Score: ${score}`;
                gameOverScreen.style.display = 'none';
                pauseMenu.style.display = 'none';
                canvas.classList.remove('blur');
                car.x = canvas.width / 2;
                obstacles.length = 0;
                trackSegments.length = 0;
                initTrack();
            }

            // Start game
            startButton.addEventListener('click', () => {
                gameStarted = true;
                startScreen.style.display = 'none';
                initTrack();
                gameLoop();
            });

            // Main game loop with input handling
            function mainLoop() {
                if (gameStarted && !gameOver) {
                    handleInput();
                }
                requestAnimationFrame(mainLoop);
            }

            // Initialize the game
            initTrack();
            draw();
            mainLoop();
        });
    </script>
</body>
</html> 