<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Psychedelic Racer 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            perspective: 800px;
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            transform-style: preserve-3d;
            transform: rotateX(30deg) rotateY(0deg);
            transition: transform 0.1s;
        }

        #gameCanvas {
            border: 2px solid #fff;
            background: #000;
            transform-style: preserve-3d;
            transform: translateZ(0);
            box-shadow: 0 0 50px rgba(255, 0, 255, 0.5);
            display: block;
        }

        #gameOver {
            position: absolute;
            color: #fff;
            font-size: 48px;
            text-align: center;
            display: none;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffff;
            transform: translateZ(200px);
            animation: pulse 2s infinite;
            width: 100%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(200px);
        }

        #gameOver.show {
            display: block;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) translateZ(200px) scale(1); }
            50% { transform: translate(-50%, -50%) translateZ(200px) scale(1.1); }
            100% { transform: translate(-50%, -50%) translateZ(200px) scale(1); }
        }

        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 24px;
            text-shadow: 0 0 5px #ff00ff, 0 0 10px #00ffff;
            transform: translateZ(200px);
            z-index: 10;
            text-align: right;
            line-height: 1.4;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        #score.show {
            opacity: 1;
        }

        #startScreen {
            position: absolute;
            color: #fff;
            text-align: center;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffff;
            transform: translateZ(200px);
            width: 100%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(200px);
        }

        #controlsManual {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 20px;
            margin: 20px auto;
            max-width: 500px;
            text-align: left;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
            min-width: 100px;
            text-align: center;
        }

        .control-description {
            flex: 1;
            margin-left: 20px;
            color: #fff;
        }

        #startButton {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            transform: translateZ(200px);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
            position: relative;
            overflow: hidden;
        }

        #startButton:hover {
            transform: translateZ(200px) scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }

        #startButton::before {
            content: '';
            position: absolute;
            top: -100%;
            left: -100%;
            width: 300%;
            height: 300%;
            background: linear-gradient(
                45deg,
                transparent,
                rgba(255, 0, 0, 0.8),    /* Red */
                rgba(255, 165, 0, 0.8),  /* Orange */
                rgba(255, 255, 0, 0.8),  /* Yellow */
                rgba(0, 255, 0, 0.8),    /* Green */
                rgba(0, 0, 255, 0.8),    /* Blue */
                rgba(75, 0, 130, 0.8),   /* Indigo */
                rgba(238, 130, 238, 0.8), /* Violet */
                transparent
            );
            transform: rotate(45deg);
            animation: shimmer 1.5s infinite;
            pointer-events: none;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%) rotate(45deg);
            }
            100% {
                transform: translateX(100%) rotate(45deg);
            }
        }

        #startButton:hover::before {
            animation: shimmer 0.8s infinite;
            background: linear-gradient(
                45deg,
                transparent,
                rgba(255, 0, 0, 1),    /* Red */
                rgba(255, 165, 0, 1),  /* Orange */
                rgba(255, 255, 0, 1),  /* Yellow */
                rgba(0, 255, 0, 1),    /* Green */
                rgba(0, 0, 255, 1),    /* Blue */
                rgba(75, 0, 130, 1),   /* Indigo */
                rgba(238, 130, 238, 1), /* Violet */
                transparent
            );
        }

        .road-line {
            position: absolute;
            background: #fff;
            width: 10px;
            height: 50px;
            transform-style: preserve-3d;
            box-shadow: 0 0 10px #fff;
        }

        #pauseMenu {
            position: absolute;
            color: #fff;
            text-align: center;
            display: none;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffff;
            width: 100%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(200px);
            z-index: 20;
            filter: none !important;
        }

        #resumeButton {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            transform: translateZ(200px);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        #resumeButton:hover {
            transform: translateZ(200px) scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }

        .blur {
            filter: blur(5px);
        }

        #gameCanvas.blur {
            filter: blur(5px);
        }

        #hyperfuelGauge {
            position: absolute;
            top: 20px;
            left: 20px;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        #hyperfuelGauge.show {
            opacity: 1;
        }

        #stillnessMeter {
            position: absolute;
            top: 50px;
            left: 20px;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        #stillnessMeter.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="score">Score: 0</div>
        <div id="gameOver">GAME OVER<br>Press R to restart</div>
        <div id="startScreen">
            <h1>PSYCHEDELIC RACER 3D</h1>
            <div id="controlsManual">
                <div class="control-row">
                    <div class="control-key">← → or A D</div>
                    <div class="control-description">Move Left/Right</div>
                </div>
                <div class="control-row">
                    <div class="control-key">SHIFT or SPACE</div>
                    <div class="control-description">Boost (Uses Hyperfuel)</div>
                </div>
                <div class="control-row">
                    <div class="control-key">ESC</div>
                    <div class="control-description">Pause Game</div>
                </div>
                <div class="control-row">
                    <div class="control-key">R</div>
                    <div class="control-description">Restart Game</div>
                </div>
            </div>
            <p>Collect coins and hyperfuel to boost your score!</p>
            <p>Avoid buildings and don't stay still for too long!</p>
            <button id="startButton">START GAME</button>
        </div>
        <div id="pauseMenu">
            <h1>PAUSED</h1>
            <p>Press ESC to resume</p>
            <button id="resumeButton">RESUME</button>
        </div>
        <canvas id="hyperfuelGauge" width="200" height="20"></canvas>
        <canvas id="stillnessMeter" width="200" height="20"></canvas>
    </div>

    <script>
        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const gameOverScreen = document.getElementById('gameOver');
            const scoreElement = document.getElementById('score');
            const startScreen = document.getElementById('startScreen');
            const startButton = document.getElementById('startButton');
            const gameContainer = document.getElementById('gameContainer');
            const pauseMenu = document.getElementById('pauseMenu');
            const resumeButton = document.getElementById('resumeButton');

            // Set canvas size
            canvas.width = 800;
            canvas.height = 600;

            // Game variables
            let gameStarted = false;
            let gameOver = false;
            let score = 0;
            let hyperfuel = 100;
            let maxHyperfuel = 100;
            let isBoosting = false;
            let boostIntensity = 0;
            let stillnessMeter = 0;
            let maxStillness = 100;
            let stillnessIncreaseRate = 0.5;
            let stillnessDecreaseRate = 1.0;
            let animationFrame;
            let hue = 0;
            let colorPhase = 0;
            let roadLines = [];
            let tilt = 0;
            let isPaused = false;
            let fadeOutOpacity = 1;
            let fadeOutTimer = 0;
            const fov = 800;
            let targetFov = 800;
            let speedMultiplier = 1.0;
            let targetSpeedMultiplier = 1.0;
            const maxSpeedMultiplier = 2.5;
            const speedIncreaseRate = 0.0001;

            // Player car
            const car = {
                x: canvas.width / 2,
                y: canvas.height - 100,
                width: 30,
                height: 48,
                speed: 8,
                z: 0,
                velocity: 0,
                rotation: 0,
                drift: false,
                driftAngle: 0,
                driftPower: 0
            };

            // Optimized particle systems
            const maxParticles = 5;
            const maxExplosionParticles = 8;
            const particles = [];
            const explosions = [];
            const explosionParticles = [];

            // Coins
            const coinsArray = [];
            const coinSize = 15;
            const coinValue = 5;

            // Hyperfuel
            const hyperfuelArray = [];
            const hyperfuelSize = 25;
            const hyperfuelValue = 25;

            // Track segments
            const trackSegments = [];
            const segmentHeight = 50;
            const trackWidth = 500;
            let trackOffset = 0;
            const maxSegments = Math.ceil(canvas.height / segmentHeight) + 2;
            let lastOffset = 0;

            // Obstacles
            const obstacles = [];
            const obstacleWidth = 50;
            const obstacleHeight = 50;
            const explosionRadius = 50; // Reduced from 100

            // Enemy car and projectiles
            const enemyCars = [];
            const enemyProjectiles = [];
            const enemyCarWidth = 30;
            const enemyCarHeight = 48;
            const projectileSize = 8;
            const projectileSpeed = 10;

            // Add to game variables
            const speedLines = [];
            const maxSpeedLines = 50; // Increased from 20 to 50
            const speedLineLength = 200; // Increased from 100 to 200
            const speedLineWidth = 3; // Increased from 2 to 3

            // Initialize track
            function initTrack() {
                trackSegments.length = 0;
                lastOffset = 0;
                for (let i = 0; i < maxSegments; i++) {
                    // Calculate smooth offset using sine wave with phase shift
                    const phase = i * 0.1;
                    const offset = Math.sin(phase) * 40;
                    
                    trackSegments.push({
                        y: i * segmentHeight,
                        offset: offset,
                        z: i * 20,
                        hue: (hue + i * 30) % 360,
                        phase: phase
                    });
                    lastOffset = offset;
                }
            }

            // Create new obstacle
            function createObstacle() {
                // Find the current track segment at the top of the screen
                const topSegment = trackSegments.find(segment => segment.y < 0 && segment.y > -segmentHeight);
                if (topSegment) {
                    const trackX = canvas.width / 2 + topSegment.offset - trackWidth / 2;
                    const randomX = trackX + Math.random() * trackWidth;
                    
                    // 10% chance to create a blinking building
                    const isBlinking = Math.random() < 0.1;
                    
                    // Create base hue
                    const baseHue = (hue + Math.random() * 360) % 360;
                    // Create contrasting hue (180 degrees apart)
                    const contrastHue = (baseHue + 180) % 360;
                    
                    obstacles.push({
                        x: randomX,
                        y: -obstacleHeight,
                        width: obstacleWidth,
                        height: obstacleHeight,
                        z: 0,
                        hue: baseHue,
                        isBlinking: isBlinking,
                        blinkTimer: 0,
                        blinkState: false,
                        explosionTimer: isBlinking ? 300 : 0,
                        originalHue: baseHue,
                        contrastHue: contrastHue
                    });
                }
            }

            // Create new coin
            function createCoin() {
                // Find the current track segment at the top of the screen
                const topSegment = trackSegments.find(segment => segment.y < 0 && segment.y > -segmentHeight);
                if (topSegment) {
                    const trackX = canvas.width / 2 + topSegment.offset - trackWidth / 2;
                    const randomX = trackX + Math.random() * trackWidth;
                    
                    coinsArray.push({
                        x: randomX,
                        y: -coinSize,
                        size: coinSize,
                        collected: false,
                        rotation: 0,
                        hue: (hue + Math.random() * 360) % 360
                    });
                }
            }

            // Create new hyperfuel
            function createHyperfuel() {
                // Find the current track segment at the top of the screen
                const topSegment = trackSegments.find(segment => segment.y < 0 && segment.y > -segmentHeight);
                if (topSegment) {
                    const trackX = canvas.width / 2 + topSegment.offset - trackWidth / 2;
                    const randomX = trackX + Math.random() * trackWidth;
                    
                    hyperfuelArray.push({
                        x: randomX,
                        y: -hyperfuelSize,
                        size: hyperfuelSize,
                        collected: false,
                        rotation: 0,
                        hue: (hue + Math.random() * 360) % 360
                    });
                }
            }

            // Create new particle
            function createParticle() {
                if (particles.length < maxParticles) {
                    particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 2 + 1,
                        speed: Math.random() * 0.3 + 0.1,
                        hue: (hue + Math.random() * 60) % 360,
                        opacity: Math.random() * 0.2 + 0.05
                    });
                }
            }

            // Update particles
            function updateParticles() {
                particles.forEach(particle => {
                    particle.y += particle.speed;
                    particle.hue = (particle.hue + 0.2) % 360;
                    
                    if (particle.y > canvas.height) {
                        particle.y = -particle.size;
                        particle.x = Math.random() * canvas.width;
                    }
                });
            }

            // Draw particles
            function drawParticles() {
                ctx.shadowBlur = 3;
                particles.forEach(particle => {
                    ctx.fillStyle = `hsla(${particle.hue}, 100%, 70%, ${particle.opacity})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // Draw coins
            function drawCoins() {
                coinsArray.forEach(coin => {
                    if (coin.collected) return;
                    
                    coin.rotation += 0.1;
                    const scale = 1 + Math.sin(coin.rotation) * 0.2;
                    
                    ctx.save();
                    ctx.translate(coin.x, coin.y);
                    ctx.scale(scale, scale);
                    ctx.rotate(coin.rotation);
                    
                    // Draw coin with metallic gradient
                    const coinGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coin.size);
                    coinGradient.addColorStop(0, `hsl(${coin.hue}, 100%, 80%)`);
                    coinGradient.addColorStop(0.5, `hsl(${coin.hue}, 100%, 60%)`);
                    coinGradient.addColorStop(1, `hsl(${coin.hue}, 100%, 40%)`);
                    
                    ctx.fillStyle = coinGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, coin.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add coin glow
                    ctx.shadowColor = `hsl(${coin.hue}, 100%, 50%)`;
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = `hsl(${coin.hue}, 100%, 90%)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add coin details
                    ctx.beginPath();
                    ctx.arc(0, 0, coin.size * 0.6, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsl(${coin.hue}, 100%, 80%)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Add coin symbol
                    ctx.fillStyle = `hsl(${coin.hue}, 100%, 90%)`;
                    ctx.font = `${coin.size}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', 0, 0);
                    
                    ctx.restore();
                });
            }

            // Draw hyperfuel
            function drawHyperfuel() {
                hyperfuelArray.forEach(hyperfuelItem => {
                    if (hyperfuelItem.collected) return;
                    
                    hyperfuelItem.rotation += 0.1;
                    const scale = 1 + Math.sin(hyperfuelItem.rotation) * 0.2;
                    
                    ctx.save();
                    ctx.translate(hyperfuelItem.x, hyperfuelItem.y);
                    ctx.scale(scale, scale);
                    ctx.rotate(hyperfuelItem.rotation);
                    
                    // Draw hyperfuel with energy gradient
                    const hyperfuelGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, hyperfuelItem.size);
                    hyperfuelGradient.addColorStop(0, `hsl(${hyperfuelItem.hue}, 100%, 90%)`);
                    hyperfuelGradient.addColorStop(0.5, `hsl(${hyperfuelItem.hue}, 100%, 70%)`);
                    hyperfuelGradient.addColorStop(1, `hsl(${hyperfuelItem.hue}, 100%, 50%)`);
                    
                    ctx.fillStyle = hyperfuelGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, hyperfuelItem.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add hyperfuel glow
                    ctx.shadowColor = `hsl(${hyperfuelItem.hue}, 100%, 70%)`;
                    ctx.shadowBlur = 20;
                    ctx.strokeStyle = `hsl(${hyperfuelItem.hue}, 100%, 90%)`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Add hyperfuel details
                    ctx.beginPath();
                    ctx.arc(0, 0, hyperfuelItem.size * 0.6, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsl(${hyperfuelItem.hue}, 100%, 90%)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add hyperfuel symbol
                    ctx.fillStyle = `hsl(${hyperfuelItem.hue}, 100%, 100%)`;
                    ctx.font = `${hyperfuelItem.size}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('⚡', 0, 0);
                    
                    ctx.restore();
                });
            }

            // Draw hyperfuel gauge
            function drawHyperfuelGauge() {
                if (!gameStarted || gameOver || isPaused) return;
                
                const gaugeWidth = 200;
                const gaugeHeight = 20;
                const gaugeX = 20;
                const gaugeY = 20;
                
                // Draw gauge background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
                
                // Draw hyperfuel level
                const hyperfuelWidth = (hyperfuel / maxHyperfuel) * gaugeWidth;
                const hyperfuelGradient = ctx.createLinearGradient(gaugeX, gaugeY, gaugeX + hyperfuelWidth, gaugeY);
                hyperfuelGradient.addColorStop(0, `hsl(${(hue + colorPhase) % 360}, 100%, 50%)`);
                hyperfuelGradient.addColorStop(1, `hsl(${(hue + colorPhase + 60) % 360}, 100%, 50%)`);
                
                ctx.fillStyle = hyperfuelGradient;
                ctx.fillRect(gaugeX, gaugeY, hyperfuelWidth, gaugeHeight);
                
                // Draw gauge border
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
                
                // Draw hyperfuel text
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.fillText(`Hyperfuel: ${Math.floor(hyperfuel)}%`, gaugeX + 10, gaugeY + 15);
            }

            // Draw stillness meter
            function drawStillnessMeter() {
                if (!gameStarted || gameOver || isPaused) return;
                
                const gaugeWidth = 200;
                const gaugeHeight = 20;
                const gaugeX = 20;
                const gaugeY = 50;
                
                // Draw gauge background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
                
                // Draw stillness level with warning colors
                const stillnessWidth = (stillnessMeter / maxStillness) * gaugeWidth;
                const stillnessGradient = ctx.createLinearGradient(gaugeX, gaugeY, gaugeX + stillnessWidth, gaugeY);
                
                // Color changes based on stillness level
                if (stillnessMeter > maxStillness * 0.8) {
                    // Red warning
                    stillnessGradient.addColorStop(0, 'hsl(0, 100%, 50%)');
                    stillnessGradient.addColorStop(1, 'hsl(0, 100%, 30%)');
                } else if (stillnessMeter > maxStillness * 0.5) {
                    // Orange warning
                    stillnessGradient.addColorStop(0, 'hsl(30, 100%, 50%)');
                    stillnessGradient.addColorStop(1, 'hsl(30, 100%, 30%)');
                } else {
                    // Yellow warning
                    stillnessGradient.addColorStop(0, 'hsl(60, 100%, 50%)');
                    stillnessGradient.addColorStop(1, 'hsl(60, 100%, 30%)');
                }
                
                ctx.fillStyle = stillnessGradient;
                ctx.fillRect(gaugeX, gaugeY, stillnessWidth, gaugeHeight);
                
                // Draw gauge border
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
                
                // Draw stillness text with warning effect
                const warningIntensity = Math.sin(Date.now() / 100) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${1 - warningIntensity * 0.5})`;
                ctx.font = '16px Arial';
                ctx.fillText(`Stillness: ${Math.floor(stillnessMeter)}%`, gaugeX + 10, gaugeY + 15);
            }

            // Create explosion with pixelated effect
            function createExplosion(x, y, hue) {
                explosions.push({
                    x: x,
                    y: y,
                    radius: 0,
                    maxRadius: 60,
                    hue: hue,
                    life: 1.0,
                    dangerZone: explosionRadius,
                    pulsePhase: 0,
                    shockwaveRadius: 0,
                    shockwaveLife: 1.0
                });

                // Create pixelated explosion particles
                const pixelSize = 4; // Size of each pixel
                const numPixels = 20; // Number of pixels in the explosion
                
                for (let i = 0; i < numPixels; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 30; // Random distance from center
                    const speed = Math.random() * 3 + 2;
                    const pixelHue = (hue + Math.random() * 60 - 30) % 360;
                    
                    explosionParticles.push({
                        x: x + Math.cos(angle) * distance,
                        y: y + Math.sin(angle) * distance,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: pixelSize,
                        hue: pixelHue,
                        life: 1.0,
                        decay: Math.random() * 0.02 + 0.01,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.2,
                        isPixel: true
                    });
                }
            }

            // Draw explosions with pixelated effect
            function drawExplosions() {
                explosions.forEach(explosion => {
                    // Draw danger zone indicator
                    ctx.save();
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 100) * 0.3;
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, explosion.dangerZone, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // Draw shockwave
                    if (explosion.shockwaveLife > 0) {
                        const shockwaveGradient = ctx.createRadialGradient(
                            explosion.x, explosion.y, 0,
                            explosion.x, explosion.y, explosion.shockwaveRadius
                        );
                        shockwaveGradient.addColorStop(0, `hsla(${explosion.hue}, 100%, 90%, ${explosion.shockwaveLife * 0.3})`);
                        shockwaveGradient.addColorStop(1, `hsla(${explosion.hue}, 100%, 50%, 0)`);
                        
                        ctx.fillStyle = shockwaveGradient;
                        ctx.beginPath();
                        ctx.arc(explosion.x, explosion.y, explosion.shockwaveRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Draw explosion core with pixelated effect
                    const coreSize = explosion.radius;
                    const pixelSize = 4;
                    const numPixels = Math.floor(coreSize / pixelSize);
                    
                    for (let i = 0; i < numPixels; i++) {
                        const angle = (i / numPixels) * Math.PI * 2;
                        const distance = Math.random() * coreSize;
                        const x = explosion.x + Math.cos(angle) * distance;
                        const y = explosion.y + Math.sin(angle) * distance;
                        
                        ctx.fillStyle = `hsla(${explosion.hue}, 100%, 90%, ${explosion.life * 0.8})`;
                        ctx.fillRect(x - pixelSize/2, y - pixelSize/2, pixelSize, pixelSize);
                    }
                });

                // Draw explosion particles with pixelated effect
                explosionParticles.forEach(particle => {
                    ctx.save();
                    ctx.translate(particle.x, particle.y);
                    ctx.rotate(particle.rotation);
                    
                    // Draw pixel with glow
                    ctx.shadowColor = `hsla(${particle.hue}, 100%, 80%, ${particle.life * 0.8})`;
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = `hsla(${particle.hue}, 100%, 90%, ${particle.life})`;
                    ctx.fillRect(-particle.size/2, -particle.size/2, particle.size, particle.size);
                    
                    // Draw pixel trail
                    ctx.strokeStyle = `hsla(${particle.hue}, 100%, 70%, ${particle.life * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-particle.vx, -particle.vy);
                    ctx.stroke();
                    
                    ctx.restore();
                });
            }

            // Update explosions with pixelated effect
            function updateExplosions() {
                explosions.forEach(explosion => {
                    explosion.radius += 5;
                    explosion.life -= 0.02;
                    explosion.pulsePhase += 0.1;
                    
                    if (explosion.shockwaveLife > 0) {
                        explosion.shockwaveRadius += 8;
                        explosion.shockwaveLife -= 0.02;
                    }
                });

                // Remove finished explosions
                for (let i = explosions.length - 1; i >= 0; i--) {
                    if (explosions[i].life <= 0) {
                        explosions.splice(i, 1);
                    }
                }

                // Update explosion particles with pixelated effect
                for (let i = explosionParticles.length - 1; i >= 0; i--) {
                    const particle = explosionParticles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life -= particle.decay;
                    particle.rotation += particle.rotationSpeed;
                    
                    // Add slight random movement to pixels
                    if (particle.isPixel) {
                        particle.vx += (Math.random() - 0.5) * 0.2;
                        particle.vy += (Math.random() - 0.5) * 0.2;
                    }
                    
                    if (particle.life <= 0) {
                        explosionParticles.splice(i, 1);
                    }
                }
            }

            // Add game over function
            function showGameOver() {
                if (!gameOver) {
                    gameOver = true;
                    gameOverScreen.style.display = 'block';
                    gameOverScreen.classList.add('show');
                }
            }

            // Update collision detection
            function checkCollisions() {
                const currentSegment = trackSegments.find(segment => 
                    segment.y <= car.y && segment.y + segmentHeight > car.y
                );
                
                if (currentSegment) {
                    const trackX = canvas.width / 2 + currentSegment.offset;
                    const trackLeft = trackX - trackWidth/2;
                    const trackRight = trackX + trackWidth/2;
                    
                    if (car.x - car.width/2 < trackLeft + 20) {
                        car.x = trackLeft + 20 + car.width/2;
                        car.velocity = -car.velocity * 0.5;
                        return false;
                    }
                    
                    if (car.x + car.width/2 > trackRight - 20) {
                        car.x = trackRight - 20 - car.width/2;
                        car.velocity = -car.velocity * 0.5;
                        return false;
                    }
                }

                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    const collision = car.x + car.width / 2 > obstacle.x &&
                                    car.x - car.width / 2 < obstacle.x + obstacle.width &&
                                    car.y + car.height / 2 > obstacle.y &&
                                    car.y - car.height / 2 < obstacle.y + obstacle.height;
                    
                    if (collision) {
                        createExplosion(
                            obstacle.x + obstacle.width/2,
                            obstacle.y + obstacle.height/2,
                            obstacle.hue
                        );
                        
                        obstacles.splice(i, 1);
                        score += 50;
                        scoreElement.innerHTML = `Score: ${score}<br>Hyperfuel: ${Math.floor(hyperfuel)}%`;
                        
                        createExplosion(car.x, car.y, hue);
                        setTimeout(showGameOver, 500);
                        return true;
                    }
                }
                
                return false;
            }

            // Update stillness meter check
            function update() {
                if (gameOver || isPaused) return;
                
                // Update speed lines
                updateSpeedLines();
                
                // Update stillness meter
                const isMoving = Math.abs(car.velocity) > 0.1 || isBoosting;
                if (isMoving) {
                    stillnessMeter = Math.max(0, stillnessMeter - stillnessDecreaseRate);
                } else {
                    stillnessMeter = Math.min(maxStillness, stillnessMeter + stillnessIncreaseRate);
                    
                    if (stillnessMeter >= maxStillness) {
                        createExplosion(car.x, car.y, hue);
                        showGameOver();
                        return;
                    }
                }
                
                // Gradually increase target speed multiplier
                targetSpeedMultiplier = Math.min(maxSpeedMultiplier, 1.0 + (score * 0.001));
                speedMultiplier += (targetSpeedMultiplier - speedMultiplier) * 0.001;
                
                // Smoothly transition boost intensity
                const targetBoostIntensity = isBoosting ? 1 : 0;
                boostIntensity += (targetBoostIntensity - boostIntensity) * 0.1;
                
                updateExplosions();
                
                // Simplified color phase update
                colorPhase = (colorPhase + 0.05) % 360;
                
                // Static game container transform - no changes during boost
                gameContainer.style.transform = `rotateX(30deg) rotateY(${tilt}deg)`;

                // Reduced particle creation
                if (Math.random() < 0.02) {
                    createParticle();
                }

                // Reduced obstacle creation
                if (Math.random() < 0.015) {
                    createObstacle();
                }

                // Reduced coin creation
                if (Math.random() < 0.01) {
                    createCoin();
                }

                // Reduced hyperfuel creation
                if (Math.random() < 0.005) {
                    createHyperfuel();
                }

                // Update particles with reduced frequency
                updateParticles();

                // Update coins
                coinsArray.forEach(coin => {
                    if (!coin.collected) {
                        coin.y += (isBoosting ? 12 : 6) * speedMultiplier;
                        coin.hue = (coin.hue + 1) % 360;
                        
                        // Check coin collection
                        if (Math.abs(car.x - coin.x) < (car.width/2 + coin.size) &&
                            Math.abs(car.y - coin.y) < (car.height/2 + coin.size)) {
                            coin.collected = true;
                            score += coinValue;
                            scoreElement.innerHTML = `Score: ${score}<br>Hyperfuel: ${Math.floor(hyperfuel)}%`;
                        }
                        
                        // Remove off-screen coins
                        if (coin.y > canvas.height) {
                            const index = coinsArray.indexOf(coin);
                            if (index > -1) {
                                coinsArray.splice(index, 1);
                            }
                        }
                    }
                });

                // Update hyperfuel
                hyperfuelArray.forEach(hyperfuelItem => {
                    if (!hyperfuelItem.collected) {
                        hyperfuelItem.y += (isBoosting ? 12 : 6) * speedMultiplier;
                        hyperfuelItem.hue = (hyperfuelItem.hue + 1) % 360;
                        
                        // Check hyperfuel collection
                        if (Math.abs(car.x - hyperfuelItem.x) < (car.width/2 + hyperfuelItem.size) &&
                            Math.abs(car.y - hyperfuelItem.y) < (car.height/2 + hyperfuelItem.size)) {
                            hyperfuelItem.collected = true;
                            hyperfuel = Math.min(maxHyperfuel, hyperfuel + hyperfuelValue);
                            score += hyperfuelValue;
                            scoreElement.innerHTML = `Score: ${score}<br>Hyperfuel: ${Math.floor(hyperfuel)}%`;
                        }
                        
                        // Remove off-screen hyperfuel
                        if (hyperfuelItem.y > canvas.height) {
                            const index = hyperfuelArray.indexOf(hyperfuelItem);
                            if (index > -1) {
                                hyperfuelArray.splice(index, 1);
                            }
                        }
                    }
                });

                // Handle hyperfuel consumption when boosting
                if (isBoosting && hyperfuel > 0) {
                    hyperfuel = Math.max(0, hyperfuel - 0.5); // Increased from 0.2 to 0.5 for faster consumption
                    if (hyperfuel <= 0) {
                        isBoosting = false;
                    }
                }

                // Update segment positions and properties with speed multiplier
                trackSegments.forEach(segment => {
                    segment.y += (isBoosting ? 12 : 6) * speedMultiplier;
                    segment.hue = (segment.hue + 0.8) % 360;
                    
                    // Update phase for smooth curve
                    segment.phase += 0.1;
                    const targetOffset = Math.sin(segment.phase) * 40;
                    
                    // Smooth transition to new offset
                    segment.offset += (targetOffset - segment.offset) * 0.1;
                    
                    // Reset segment position when it goes off screen
                    if (segment.y > canvas.height) {
                        segment.y = -segmentHeight;
                        segment.z = 0;
                        const lastSegment = trackSegments[trackSegments.length - 1];
                        segment.phase = lastSegment.phase + 0.1;
                        segment.offset = lastSegment.offset;
                        segment.hue = (lastSegment.hue + 30) % 360;
                    }
                });

                // Move obstacles with speed multiplier
                obstacles.forEach((obstacle, index) => {
                    obstacle.y += (isBoosting ? 16 : 8) * speedMultiplier;
                    obstacle.z += (isBoosting ? 1.2 : 0.6) * speedMultiplier;
                    obstacle.hue = (obstacle.hue + 1.5) % 360;

                    // Check if blinking building has reached car level
                    if (obstacle.isBlinking && Math.abs(obstacle.y - car.y) < 20) {
                        createExplosion(
                            obstacle.x + obstacle.width/2,
                            obstacle.y + obstacle.height/2,
                            obstacle.hue
                        );
                        
                        // Check if car is within explosion radius
                        const dx = car.x - (obstacle.x + obstacle.width/2);
                        const dy = car.y - (obstacle.y + obstacle.height/2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < explosionRadius) {
                            createExplosion(car.x, car.y, hue);
                            showGameOver();
                        }
                        
                        // Remove the building
                        obstacles.splice(index, 1);
                        return;
                    }
                });

                // Remove off-screen obstacles
                obstacles.forEach((obstacle, index) => {
                    if (obstacle.y > canvas.height) {
                        obstacles.splice(index, 1);
                        score += 10;
                        scoreElement.textContent = `Score: ${score}`;
                    }
                });

                // Create new obstacles more frequently
                if (Math.random() < 0.03) {
                    createObstacle();
                }

                // Create new coins
                if (Math.random() < 0.02) {
                    createCoin();
                }

                // Create new hyperfuel
                if (Math.random() < 0.01) {
                    createHyperfuel();
                }

                // Update container tilt based on car position and velocity
                const currentSegment = trackSegments.find(segment => 
                    segment.y <= car.y && segment.y + segmentHeight > car.y
                );
                
                if (currentSegment) {
                    const trackX = canvas.width / 2 + currentSegment.offset;
                    const targetTilt = ((car.x - trackX) / (trackWidth/2)) * 10;
                    const tiltDirection = car.velocity > 0 ? -1 : 1;
                    tilt += (targetTilt * tiltDirection - tilt) * 0.12;
                    gameContainer.style.transform = `rotateX(30deg) rotateY(${tilt}deg)`;
                }

                // Check collisions
                if (checkCollisions()) {
                    gameOver = true;
                    gameOverScreen.style.display = 'block';
                }
            }

            // Optimized draw function
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Batch similar drawing operations
                ctx.save();
                drawBackground();
                drawTrack();
                drawParticles();
                drawCoins();
                drawHyperfuel();
                drawObstacles();
                drawExplosions();
                drawSpeedLines();
                drawCar();
                drawHyperfuelGauge();
                drawStillnessMeter();
                ctx.restore();

                // Add bright overlay with smooth transition
                if (boostIntensity > 0) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.2 * boostIntensity})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }

            // Draw psychedelic background
            function drawBackground() {
                hue = (hue + 0.3) % 360;
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                
                // Enhanced brightness when boosting with smooth transition
                const brightness = 50 + (boostIntensity * 20); // Base 50% + up to 20% more
                const alpha = 0.3 + (boostIntensity * 0.1); // Base 0.3 + up to 0.1 more
                
                gradient.addColorStop(0, `hsla(${(hue + colorPhase) % 360}, 100%, ${brightness}%, ${alpha})`);
                gradient.addColorStop(0.5, `hsla(${(hue + colorPhase + 120) % 360}, 100%, ${brightness}%, ${alpha * 0.8})`);
                gradient.addColorStop(1, `hsla(${(hue + colorPhase + 240) % 360}, 100%, ${brightness}%, ${alpha})`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw vaporwave grid with modulated colors
                const gridSize = 40;
                const gridColor = `hsla(${(hue + colorPhase + 180) % 360}, 100%, 50%, 0.1)`;
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1;

                // Draw vertical lines
                for (let x = 0; x < canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }

                // Draw horizontal lines
                for (let y = 0; y < canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                // Add perspective effect to grid
                ctx.save();
                ctx.translate(canvas.width/2, canvas.height/2);
                ctx.scale(1, 0.5);
                ctx.translate(-canvas.width/2, -canvas.height/2);
                
                // Draw diagonal lines for vaporwave effect
                const diagonalColor = `hsla(${(hue + colorPhase + 90) % 360}, 100%, 50%, 0.15)`;
                ctx.strokeStyle = diagonalColor;
                for (let i = -canvas.width; i < canvas.width * 2; i += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + canvas.height, canvas.height);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Draw track with 3D effect
            function drawTrack() {
                // Draw segments that are visible on screen
                trackSegments.forEach((segment, index) => {
                    const y = segment.y;
                    if (y < -segmentHeight || y > canvas.height) return;
                    
                    const x = canvas.width / 2 + segment.offset - trackWidth / 2;
                    const scale = 1 + (segment.z / 800);
                    const tilt = Math.sin(y / 100) * 3;
                    
                    ctx.save();
                    ctx.translate(x + trackWidth/2, y + segmentHeight/2);
                    ctx.scale(scale, scale);
                    ctx.rotate(tilt * Math.PI / 180);
                    ctx.translate(-(x + trackWidth/2), -(y + segmentHeight/2));
                    
                    // Draw track base with modulated gradient
                    const trackGradient = ctx.createLinearGradient(x, y, x, y + segmentHeight);
                    trackGradient.addColorStop(0, `hsla(${(segment.hue + colorPhase) % 360}, 100%, 20%, 0.9)`);
                    trackGradient.addColorStop(0.5, `hsla(${(segment.hue + colorPhase + 60) % 360}, 100%, 30%, 0.9)`);
                    trackGradient.addColorStop(1, `hsla(${(segment.hue + colorPhase) % 360}, 100%, 20%, 0.9)`);
                    ctx.fillStyle = trackGradient;
                    ctx.fillRect(x, y, trackWidth, segmentHeight);
                    
                    // Simplified track surface pattern
                    const patternSize = 30;
                    const patternColor = `hsla(${(segment.hue + colorPhase + 180) % 360}, 100%, 50%, 0.05)`;
                    ctx.strokeStyle = patternColor;
                    ctx.lineWidth = 1;
                    
                    // Draw diagonal pattern with reduced frequency
                    for (let i = -trackWidth; i < trackWidth * 2; i += patternSize * 2) {
                        ctx.beginPath();
                        ctx.moveTo(x + i, y);
                        ctx.lineTo(x + i + segmentHeight, y + segmentHeight);
                        ctx.stroke();
                    }
                    
                    // Draw track borders with simplified glow
                    ctx.shadowColor = `hsl(${segment.hue}, 100%, 50%)`;
                    ctx.shadowBlur = 10;
                    
                    // Left barrier with simplified gradient
                    const leftBarrierGradient = ctx.createLinearGradient(x, y, x + 20, y);
                    leftBarrierGradient.addColorStop(0, `hsla(${segment.hue}, 100%, 80%, 0.8)`);
                    leftBarrierGradient.addColorStop(1, `hsla(${segment.hue}, 100%, 50%, 0.4)`);
                    ctx.fillStyle = leftBarrierGradient;
                    ctx.fillRect(x, y, 20, segmentHeight);
                    
                    // Right barrier with simplified gradient
                    const rightBarrierGradient = ctx.createLinearGradient(x + trackWidth - 20, y, x + trackWidth, y);
                    rightBarrierGradient.addColorStop(0, `hsla(${segment.hue}, 100%, 50%, 0.4)`);
                    rightBarrierGradient.addColorStop(1, `hsla(${segment.hue}, 100%, 80%, 0.8)`);
                    ctx.fillStyle = rightBarrierGradient;
                    ctx.fillRect(x + trackWidth - 20, y, 20, segmentHeight);
                    
                    // Draw center line with simplified animation
                    const centerLineWidth = 4;
                    const centerLineOffset = Math.sin((y + trackOffset) / 30) * 5;
                    ctx.fillStyle = `hsl(${(segment.hue + colorPhase + 120) % 360}, 100%, 80%)`;
                    ctx.shadowColor = `hsl(${(segment.hue + colorPhase + 120) % 360}, 100%, 50%)`;
                    ctx.shadowBlur = 8;
                    ctx.fillRect(
                        x + trackWidth/2 - centerLineWidth/2 + centerLineOffset,
                        y,
                        centerLineWidth,
                        segmentHeight
                    );
                    
                    // Draw side lines with simplified animation
                    const sideLineWidth = 2;
                    const sideLineOffset = Math.sin((y + trackOffset) / 40) * 3;
                    ctx.fillStyle = `hsl(${(segment.hue + colorPhase + 180) % 360}, 100%, 80%)`;
                    ctx.shadowColor = `hsl(${(segment.hue + colorPhase + 180) % 360}, 100%, 50%)`;
                    ctx.shadowBlur = 5;
                    
                    // Left side line
                    ctx.fillRect(
                        x + trackWidth/4 - sideLineWidth/2 + sideLineOffset,
                        y,
                        sideLineWidth,
                        segmentHeight
                    );
                    
                    // Right side line
                    ctx.fillRect(
                        x + trackWidth*3/4 - sideLineWidth/2 - sideLineOffset,
                        y,
                        sideLineWidth,
                        segmentHeight
                    );
                    
                    ctx.restore();
                });
            }

            // Draw car with 3D effect
            function drawCar() {
                const scale = 1 + (car.z / 800);
                const tilt = Math.sin(Date.now() / 200) * 5;
                
                ctx.save();
                ctx.translate(car.x, car.y);
                ctx.scale(scale, scale);
                ctx.rotate((tilt + car.driftAngle) * Math.PI / 180);
                ctx.translate(-car.x, -car.y);
                
                // Main body with modulated gradient and smooth boost transition
                const carGradient = ctx.createLinearGradient(
                    car.x - car.width/2,
                    car.y - car.height/2,
                    car.x + car.width/2,
                    car.y + car.height/2
                );
                
                // Enhanced colors with smooth boost transition
                const baseBrightness = 60;
                const boostBrightness = 80;
                const currentBrightness = baseBrightness + (boostIntensity * (boostBrightness - baseBrightness));
                
                carGradient.addColorStop(0, `hsl(${(hue + colorPhase) % 360}, 100%, ${currentBrightness}%)`);
                carGradient.addColorStop(0.3, `hsl(${(hue + colorPhase + 180) % 360}, 100%, ${currentBrightness - 20}%)`);
                carGradient.addColorStop(0.7, `hsl(${(hue + colorPhase + 180) % 360}, 100%, ${currentBrightness - 20}%)`);
                carGradient.addColorStop(1, `hsl(${(hue + colorPhase) % 360}, 100%, ${currentBrightness}%)`);
                
                // Draw car body with dynamic outline and architectural details
                ctx.lineWidth = 3;
                ctx.strokeStyle = `hsl(${(hue + colorPhase) % 360}, 100%, 90%)`;
                ctx.shadowColor = `hsl(${(hue + colorPhase) % 360}, 100%, 70%)`;
                ctx.shadowBlur = 10;
                ctx.fillStyle = carGradient;
                
                // Draw main body with futuristic shape
                ctx.beginPath();
                ctx.moveTo(car.x - car.width/2, car.y - car.height/3);
                ctx.lineTo(car.x - car.width/3, car.y - car.height/2);
                ctx.lineTo(car.x + car.width/3, car.y - car.height/2);
                ctx.lineTo(car.x + car.width/2, car.y - car.height/3);
                ctx.lineTo(car.x + car.width/2, car.y + car.height/3);
                ctx.lineTo(car.x + car.width/3, car.y + car.height/2);
                ctx.lineTo(car.x - car.width/3, car.y + car.height/2);
                ctx.lineTo(car.x - car.width/2, car.y + car.height/3);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Add architectural details (horizontal lines)
                const detailSpacing = car.height / 4;
                for (let i = 1; i < 4; i++) {
                    const detailY = car.y - car.height/2 + i * detailSpacing;
                    ctx.beginPath();
                    ctx.moveTo(car.x - car.width/2, detailY);
                    ctx.lineTo(car.x + car.width/2, detailY);
                    ctx.strokeStyle = `hsla(${(hue + colorPhase + 180) % 360}, 100%, 50%, 0.5)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // Draw windows with dynamic outline and glowing effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.strokeStyle = `hsl(${(hue + colorPhase + 120) % 360}, 100%, 90%)`;
                ctx.shadowColor = `hsl(${(hue + colorPhase + 120) % 360}, 100%, 70%)`;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(car.x - car.width/3, car.y - car.height/3);
                ctx.lineTo(car.x + car.width/3, car.y - car.height/3);
                ctx.lineTo(car.x + car.width/4, car.y);
                ctx.lineTo(car.x - car.width/4, car.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Add window details (vertical lines)
                const windowDetailSpacing = car.width / 4;
                for (let i = 1; i < 3; i++) {
                    const detailX = car.x - car.width/3 + i * windowDetailSpacing;
                    ctx.beginPath();
                    ctx.moveTo(detailX, car.y - car.height/3);
                    ctx.lineTo(detailX, car.y);
                    ctx.strokeStyle = `hsla(${(hue + colorPhase + 120) % 360}, 100%, 70%, 0.5)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // Draw spoiler with dynamic outline and glowing effect
                ctx.fillStyle = carGradient;
                ctx.strokeStyle = `hsl(${(hue + colorPhase + 60) % 360}, 100%, 90%)`;
                ctx.shadowColor = `hsl(${(hue + colorPhase + 60) % 360}, 100%, 70%)`;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(car.x - car.width/2, car.y + car.height/3);
                ctx.lineTo(car.x - car.width/2, car.y + car.height/2);
                ctx.lineTo(car.x + car.width/2, car.y + car.height/2);
                ctx.lineTo(car.x + car.width/2, car.y + car.height/3);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Add spoiler details
                const spoilerDetailSpacing = car.width / 4;
                for (let i = 1; i < 3; i++) {
                    const detailX = car.x - car.width/2 + i * spoilerDetailSpacing;
                    ctx.beginPath();
                    ctx.moveTo(detailX, car.y + car.height/3);
                    ctx.lineTo(detailX, car.y + car.height/2);
                    ctx.strokeStyle = `hsla(${(hue + colorPhase + 60) % 360}, 100%, 70%, 0.5)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // Draw wheels with dynamic outline and glowing effect
                const wheelRadius = car.width/6;
                const wheelY = car.y + car.height/2;
                
                // Left wheel
                ctx.beginPath();
                ctx.arc(car.x - car.width/3, wheelY, wheelRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.strokeStyle = `hsl(${(hue + colorPhase + 180) % 360}, 100%, 90%)`;
                ctx.shadowColor = `hsl(${(hue + colorPhase + 180) % 360}, 100%, 70%)`;
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.stroke();
                
                // Add wheel details
                ctx.beginPath();
                ctx.arc(car.x - car.width/3, wheelY, wheelRadius * 0.6, 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${(hue + colorPhase + 180) % 360}, 100%, 70%, 0.5)`;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Right wheel
                ctx.beginPath();
                ctx.arc(car.x + car.width/3, wheelY, wheelRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Add wheel details
                ctx.beginPath();
                ctx.arc(car.x + car.width/3, wheelY, wheelRadius * 0.6, 0, Math.PI * 2);
                ctx.stroke();
                
                // Enhanced engine effects when boosting
                if (isBoosting) {
                    // Add boost trails with enhanced glow
                    const trailGradient = ctx.createLinearGradient(
                        car.x - car.width/2, car.y + car.height/2,
                        car.x - car.width/2, car.y + car.height/2 + 40
                    );
                    trailGradient.addColorStop(0, `hsla(${(hue + colorPhase + 60) % 360}, 100%, 90%, 0.8)`);
                    trailGradient.addColorStop(1, `hsla(${(hue + colorPhase + 60) % 360}, 100%, 90%, 0)`);
                    
                    ctx.fillStyle = trailGradient;
                    ctx.beginPath();
                    ctx.moveTo(car.x - car.width/3, car.y + car.height/2);
                    ctx.lineTo(car.x + car.width/3, car.y + car.height/2);
                    ctx.lineTo(car.x, car.y + car.height/2 + 40);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add boost particles with enhanced glow
                    for (let i = 0; i < 5; i++) {
                        const particleX = car.x + (Math.random() - 0.5) * car.width;
                        const particleY = car.y + car.height/2 + Math.random() * 30;
                        const particleSize = Math.random() * 4 + 2;
                        
                        ctx.fillStyle = `hsla(${(hue + colorPhase + 60) % 360}, 100%, 90%, ${Math.random() * 0.5 + 0.5})`;
                        ctx.shadowColor = `hsla(${(hue + colorPhase + 60) % 360}, 100%, 70%, 0.8)`;
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            }

            // Draw obstacles with 3D effect
            function drawObstacles() {
                obstacles.forEach(obstacle => {
                    const scale = 1 + (obstacle.z / 800);
                    const tilt = Math.sin(Date.now() / 300 + obstacle.x) * 5;
                    
                    ctx.save();
                    ctx.translate(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
                    ctx.scale(scale, scale);
                    ctx.rotate(tilt * Math.PI / 180);
                    ctx.translate(-(obstacle.x + obstacle.width/2), -(obstacle.y + obstacle.height/2));
                    
                    // Update blinking state
                    if (obstacle.isBlinking) {
                        obstacle.blinkTimer++;
                        if (obstacle.blinkTimer >= 10) { // Blink every 10 frames
                            obstacle.blinkState = !obstacle.blinkState;
                            obstacle.blinkTimer = 0;
                        }
                        
                        // Countdown to explosion
                        obstacle.explosionTimer--;
                        if (obstacle.explosionTimer <= 0) {
                            createExplosion(
                                obstacle.x + obstacle.width/2,
                                obstacle.y + obstacle.height/2,
                                obstacle.hue
                            );
                            
                            // Check if car is within explosion radius
                            const dx = car.x - (obstacle.x + obstacle.width/2);
                            const dy = car.y - (obstacle.y + obstacle.height/2);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < explosionRadius) {
                                createExplosion(car.x, car.y, hue);
                                showGameOver();
                            }
                            
                            // Remove the building
                            const index = obstacles.indexOf(obstacle);
                            if (index > -1) {
                                obstacles.splice(index, 1);
                            }
                            return;
                        }
                    }
                    
                    // Draw building base with modulated gradient
                    const buildingGradient = ctx.createLinearGradient(
                        obstacle.x,
                        obstacle.y,
                        obstacle.x,
                        obstacle.y + obstacle.height
                    );
                    
                    // Use contrasting colors for blinking buildings
                    const currentHue = obstacle.isBlinking && obstacle.blinkState ? 
                        obstacle.contrastHue : obstacle.originalHue;
                    
                    // Enhanced building colors with smooth boost transition
                    const baseBrightness = 30;
                    const boostBrightness = 50;
                    const currentBrightness = baseBrightness + (boostIntensity * (boostBrightness - baseBrightness));
                    
                    buildingGradient.addColorStop(0, `hsl(${(currentHue + colorPhase) % 360}, 100%, ${currentBrightness}%)`);
                    buildingGradient.addColorStop(0.5, `hsl(${(currentHue + colorPhase + 60) % 360}, 100%, ${currentBrightness - 10}%)`);
                    buildingGradient.addColorStop(1, `hsl(${(currentHue + colorPhase) % 360}, 100%, ${currentBrightness - 20}%)`);
                    ctx.fillStyle = buildingGradient;
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Add building details
                    const windowSize = 8;
                    const windowSpacing = 12;
                    const windowRows = Math.floor(obstacle.height / windowSpacing);
                    const windowCols = Math.floor(obstacle.width / windowSpacing);
                    
                    // Draw windows with blinking effect
                    for (let row = 0; row < windowRows; row++) {
                        for (let col = 0; col < windowCols; col++) {
                            const windowX = obstacle.x + col * windowSpacing + (windowSpacing - windowSize) / 2;
                            const windowY = obstacle.y + row * windowSpacing + (windowSpacing - windowSize) / 2;
                            
                            // Random window glow with blinking effect
                            const glowIntensity = obstacle.isBlinking && obstacle.blinkState ? 
                                Math.random() * 0.8 + 0.2 : Math.random() * 0.4 + 0.1;
                            ctx.fillStyle = `hsla(${(currentHue + colorPhase + 120) % 360}, 100%, 70%, ${glowIntensity})`;
                            ctx.shadowColor = `hsla(${(currentHue + colorPhase + 120) % 360}, 100%, 50%, ${glowIntensity})`;
                            ctx.shadowBlur = 5;
                            ctx.fillRect(windowX, windowY, windowSize, windowSize);
                        }
                    }
                    
                    // Add warning effect for buildings about to explode
                    if (obstacle.isBlinking && obstacle.explosionTimer < 60) {
                        const warningSize = obstacle.explosionTimer / 2;
                        ctx.fillStyle = `hsla(${(currentHue + colorPhase + 180) % 360}, 100%, 70%, ${0.5 + Math.sin(Date.now() / 100) * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width/2, obstacle.y - 20, warningSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Add building edges with glow
                    ctx.shadowColor = `hsl(${obstacle.hue}, 100%, 50%)`;
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = `hsl(${obstacle.hue}, 100%, 70%)`;
                    ctx.lineWidth = 2;
                    
                    // Draw vertical edges
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x, obstacle.y);
                    ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
                    ctx.moveTo(obstacle.x + obstacle.width, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                    ctx.stroke();
                    
                    // Draw horizontal edges
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y);
                    ctx.moveTo(obstacle.x, obstacle.y + obstacle.height);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                    ctx.stroke();
                    
                    // Add architectural details
                    const detailSpacing = obstacle.height / 4;
                    for (let i = 1; i < 4; i++) {
                        const detailY = obstacle.y + i * detailSpacing;
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, detailY);
                        ctx.lineTo(obstacle.x + obstacle.width, detailY);
                        ctx.strokeStyle = `hsla(${(obstacle.hue + colorPhase + 180) % 360}, 100%, 50%, 0.5)`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    
                    // Add antenna/spire
                    const spireHeight = obstacle.height * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width/2, obstacle.y - spireHeight);
                    ctx.strokeStyle = `hsl(${(obstacle.hue + colorPhase + 60) % 360}, 100%, 70%)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add spire glow
                    ctx.fillStyle = `hsl(${(obstacle.hue + colorPhase + 60) % 360}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(obstacle.x + obstacle.width/2, obstacle.y - spireHeight, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                });
            }

            // Create speed line
            function createSpeedLine() {
                if (speedLines.length < maxSpeedLines) {
                    // Spawn lines from the edges of the screen
                    let x, y;
                    const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
                    
                    switch(side) {
                        case 0: // top
                            x = Math.random() * canvas.width;
                            y = -20;
                            break;
                        case 1: // right
                            x = canvas.width + 20;
                            y = Math.random() * canvas.height;
                            break;
                        case 2: // bottom
                            x = Math.random() * canvas.width;
                            y = canvas.height + 20;
                            break;
                        case 3: // left
                            x = -20;
                            y = Math.random() * canvas.height;
                            break;
                    }
                    
                    // Calculate angle towards car
                    const dx = car.x - x;
                    const dy = car.y - y;
                    const angle = Math.atan2(dy, dx);
                    
                    speedLines.push({
                        x: x,
                        y: y,
                        angle: angle,
                        length: speedLineLength,
                        opacity: Math.random() * 0.7 + 0.3,
                        hue: (hue + Math.random() * 60) % 360,
                        speed: Math.random() * 8 + 8,
                        targetX: car.x,
                        targetY: car.y
                    });
                }
            }

            function updateSpeedLines() {
                // Update and remove old lines
                for (let i = speedLines.length - 1; i >= 0; i--) {
                    const line = speedLines[i];
                    
                    // Move line towards car
                    const dx = line.targetX - line.x;
                    const dy = line.targetY - line.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 10) { // Remove when close to car
                        speedLines.splice(i, 1);
                    } else {
                        // Move line towards car
                        line.x += Math.cos(line.angle) * line.speed;
                        line.y += Math.sin(line.angle) * line.speed;
                        
                        // Update angle to follow car movement
                        const newDx = line.targetX - line.x;
                        const newDy = line.targetY - line.y;
                        line.angle = Math.atan2(newDy, newDx);
                    }
                }
                
                // Create new lines during boost
                if (isBoosting && Math.random() < 0.6) {
                    createSpeedLine();
                }
            }

            function drawSpeedLines() {
                if (!isBoosting) return;
                
                speedLines.forEach(line => {
                    const endX = line.x + Math.cos(line.angle) * line.length;
                    const endY = line.y + Math.sin(line.angle) * line.length;
                    
                    ctx.beginPath();
                    ctx.moveTo(line.x, line.y);
                    ctx.lineTo(endX, endY);
                    
                    // Create gradient for the line with enhanced glow
                    const gradient = ctx.createLinearGradient(line.x, line.y, endX, endY);
                    gradient.addColorStop(0, `hsla(${line.hue}, 100%, 95%, ${line.opacity})`);
                    gradient.addColorStop(0.3, `hsla(${line.hue}, 100%, 90%, ${line.opacity * 0.9})`);
                    gradient.addColorStop(1, `hsla(${line.hue}, 100%, 80%, 0)`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = speedLineWidth;
                    ctx.lineCap = 'round';
                    
                    // Add stronger glow effect
                    ctx.shadowColor = `hsla(${line.hue}, 100%, 90%, ${line.opacity * 0.7})`;
                    ctx.shadowBlur = 15;
                    ctx.stroke();
                });
            }

            // Game loop
            function gameLoop() {
                if (!isPaused) {
                    update();
                }
                draw();
                animationFrame = requestAnimationFrame(gameLoop);
            }

            // Handle keyboard input
            const keys = {};
            window.addEventListener('keydown', e => {
                keys[e.key] = true;
                if (gameOver && e.key === 'r') {
                    resetGame();
                }
                if (e.key === 'Escape' && gameStarted && !gameOver) {
                    togglePause();
                }
            });
            window.addEventListener('keyup', e => {
                keys[e.key] = false;
            });

            // Update car position based on input
            function handleInput() {
                const baseMaxVelocity = 15;
                const boostMultiplier = 2.5;
                const maxVelocity = (isBoosting ? baseMaxVelocity * boostMultiplier : baseMaxVelocity) * speedMultiplier;
                const acceleration = (isBoosting ? 1.2 : 0.6) * speedMultiplier;
                const deceleration = (isBoosting ? 0.8 : 0.4) * speedMultiplier;
                const driftThreshold = 1.0;
                const maxDriftAngle = 25;
                const trackFollowSpeed = 0.08;

                // Handle boost input - removed transform changes
                if ((keys['Shift'] || keys[' ']) && hyperfuel > 0) {
                    isBoosting = true;
                } else {
                    isBoosting = false;
                }

                // Find the current track segment the car is on
                const currentSegment = trackSegments.find(segment => 
                    segment.y <= car.y && segment.y + segmentHeight > car.y
                );

                if (currentSegment) {
                    // Calculate the target position based on track offset
                    const targetX = canvas.width / 2 + currentSegment.offset;
                    
                    // Handle left/right movement with track following
                    if (keys['ArrowLeft'] || keys['a']) {
                        car.velocity = Math.max(-maxVelocity, car.velocity - acceleration);
                        if (Math.abs(car.velocity) > driftThreshold) {
                            car.drift = true;
                            car.driftAngle = Math.min(maxDriftAngle, car.driftAngle + 2);
                        }
                    } else if (keys['ArrowRight'] || keys['d']) {
                        car.velocity = Math.min(maxVelocity, car.velocity + acceleration);
                        if (Math.abs(car.velocity) > driftThreshold) {
                            car.drift = true;
                            car.driftAngle = Math.max(-maxDriftAngle, car.driftAngle - 2);
                        }
                    } else {
                        // Decelerate when no input
                        if (car.velocity > 0) {
                            car.velocity = Math.max(0, car.velocity - deceleration);
                        } else if (car.velocity < 0) {
                            car.velocity = Math.min(0, car.velocity + deceleration);
                        }
                        
                        // Reduce drift angle when not actively drifting
                        if (Math.abs(car.driftAngle) > 0) {
                            car.driftAngle *= 0.95;
                            if (Math.abs(car.driftAngle) < 0.1) {
                                car.driftAngle = 0;
                                car.drift = false;
                            }
                        }
                    }

                    // Update car position with momentum and track following
                    const trackLeft = targetX - trackWidth/2 + car.width/2;
                    const trackRight = targetX + trackWidth/2 - car.width/2;
                    
                    // Apply velocity with full effect
                    car.x += car.velocity;
                    
                    // Keep car within track boundaries
                    car.x = Math.max(trackLeft, Math.min(trackRight, car.x));
                }
            }

            // Toggle pause state
            function togglePause() {
                isPaused = !isPaused;
                if (isPaused) {
                    pauseMenu.style.display = 'block';
                    canvas.classList.add('blur');
                } else {
                    pauseMenu.style.display = 'none';
                    canvas.classList.remove('blur');
                }
            }

            // Resume button click handler
            resumeButton.addEventListener('click', () => {
                togglePause();
            });

            // Reset game
            function resetGame() {
                gameOver = false;
                isPaused = false;
                score = 0;
                hyperfuel = 100;
                isBoosting = false;
                stillnessMeter = 0;
                scoreElement.innerHTML = `Score: ${score}<br>Hyperfuel: ${Math.floor(hyperfuel)}%`;
                gameOverScreen.style.display = 'none';
                gameOverScreen.classList.remove('show');
                pauseMenu.style.display = 'none';
                canvas.classList.remove('blur');
                car.x = canvas.width / 2;
                obstacles.length = 0;
                coinsArray.length = 0;
                hyperfuelArray.length = 0;
                particles.length = 0;
                trackSegments.length = 0;
                initTrack();
            }

            // Start game
            startButton.addEventListener('click', () => {
                gameStarted = true;
                startScreen.style.display = 'none';
                scoreElement.classList.add('show');
                document.getElementById('hyperfuelGauge').classList.add('show');
                document.getElementById('stillnessMeter').classList.add('show');
                initTrack();
                gameLoop();
            });

            // Main game loop with input handling
            function mainLoop() {
                if (gameStarted && !gameOver) {
                    handleInput();
                }
                requestAnimationFrame(mainLoop);
            }

            // Initialize the game
            initTrack();
            draw();
            mainLoop();
        });
    </script>
</body>
</html> 