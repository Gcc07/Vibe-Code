<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Psychedelic Racer 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
            perspective: 800px;
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            transform-style: preserve-3d;
            transform: rotateX(30deg) rotateY(0deg);
            transition: transform 0.1s;
        }

        #gameCanvas {
            border: 2px solid #fff;
            background: #000;
            transform-style: preserve-3d;
            transform: translateZ(0);
            box-shadow: 0 0 50px rgba(255, 0, 255, 0.5);
            display: block;
        }

        #gameOver {
            position: absolute;
            color: #fff;
            font-size: 48px;
            text-align: center;
            display: none;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffff;
            transform: translateZ(200px);
            animation: pulse 2s infinite;
            width: 100%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(200px);
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) translateZ(200px) scale(1); }
            50% { transform: translate(-50%, -50%) translateZ(200px) scale(1.1); }
            100% { transform: translate(-50%, -50%) translateZ(200px) scale(1); }
        }

        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #fff;
            font-size: 24px;
            text-shadow: 0 0 5px #ff00ff, 0 0 10px #00ffff;
            transform: translateZ(200px);
            z-index: 10;
            text-align: right;
            line-height: 1.4;
        }

        #startScreen {
            position: absolute;
            color: #fff;
            text-align: center;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffff;
            transform: translateZ(200px);
            width: 100%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(200px);
        }

        #startButton {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            transform: translateZ(200px);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        #startButton:hover {
            transform: translateZ(200px) scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }

        .road-line {
            position: absolute;
            background: #fff;
            width: 10px;
            height: 50px;
            transform-style: preserve-3d;
            box-shadow: 0 0 10px #fff;
        }

        #pauseMenu {
            position: absolute;
            color: #fff;
            text-align: center;
            display: none;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffff;
            width: 100%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) translateZ(200px);
            z-index: 20;
            filter: none !important;
        }

        #resumeButton {
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: none;
            padding: 15px 30px;
            font-size: 24px;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            transform: translateZ(200px);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        #resumeButton:hover {
            transform: translateZ(200px) scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }

        .blur {
            filter: blur(5px);
        }

        #gameCanvas.blur {
            filter: blur(5px);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="score">Score: 0</div>
        <div id="gameOver">GAME OVER<br>Press R to restart</div>
        <div id="startScreen">
            <h1>PSYCHEDELIC RACER 3D</h1>
            <p>Use arrow keys or WASD to move</p>
            <button id="startButton">START GAME</button>
        </div>
        <div id="pauseMenu">
            <h1>PAUSED</h1>
            <p>Press ESC to resume</p>
            <button id="resumeButton">RESUME</button>
        </div>
    </div>

    <script>
        // Wait for DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const gameOverScreen = document.getElementById('gameOver');
            const scoreElement = document.getElementById('score');
            const startScreen = document.getElementById('startScreen');
            const startButton = document.getElementById('startButton');
            const gameContainer = document.getElementById('gameContainer');
            const pauseMenu = document.getElementById('pauseMenu');
            const resumeButton = document.getElementById('resumeButton');

            // Set canvas size
            canvas.width = 800;
            canvas.height = 600;

            // Game variables
            let gameStarted = false;
            let gameOver = false;
            let score = 0;
            let hyperfuel = 100;
            let maxHyperfuel = 100;
            let isBoosting = false;
            let animationFrame;
            let hue = 0;
            let roadLines = [];
            let tilt = 0;
            let isPaused = false;
            let fadeOutOpacity = 1;
            let fadeOutTimer = 0;
            let screenShake = { x: 0, y: 0, intensity: 0 };
            const fov = 800; // Constant FOV value
            let targetFov = 800; // Target FOV for smooth transitions

            // Coins
            const coinsArray = [];
            const coinSize = 15;
            const coinValue = 5;

            // Hyperfuel
            const hyperfuelArray = [];
            const hyperfuelSize = 25;
            const hyperfuelValue = 25;

            // Particles
            const particles = [];
            const maxParticles = 20;

            // Player car
            const car = {
                x: canvas.width / 2,
                y: canvas.height - 100,
                width: 30,
                height: 48,
                speed: 8,
                z: 0,
                velocity: 0,
                rotation: 0,
                drift: false,
                driftAngle: 0,
                driftPower: 0
            };

            // Track segments
            const trackSegments = [];
            const segmentHeight = 50;
            const trackWidth = 500;
            let trackOffset = 0;
            const maxSegments = Math.ceil(canvas.height / segmentHeight) + 2;
            let lastOffset = 0;

            // Obstacles
            const obstacles = [];
            const obstacleWidth = 50;
            const obstacleHeight = 50;

            // Initialize track
            function initTrack() {
                trackSegments.length = 0;
                lastOffset = 0;
                for (let i = 0; i < maxSegments; i++) {
                    // Calculate smooth offset using sine wave with phase shift
                    const phase = i * 0.1;
                    const offset = Math.sin(phase) * 40;
                    
                    trackSegments.push({
                        y: i * segmentHeight,
                        offset: offset,
                        z: i * 20,
                        hue: (hue + i * 30) % 360,
                        phase: phase
                    });
                    lastOffset = offset;
                }
            }

            // Create new obstacle
            function createObstacle() {
                // Find the current track segment at the top of the screen
                const topSegment = trackSegments.find(segment => segment.y < 0 && segment.y > -segmentHeight);
                if (topSegment) {
                    const trackX = canvas.width / 2 + topSegment.offset - trackWidth / 2;
                    const randomX = trackX + Math.random() * trackWidth;
                    
                    obstacles.push({
                        x: randomX,
                        y: -obstacleHeight,
                        width: obstacleWidth,
                        height: obstacleHeight,
                        z: 0,
                        hue: (hue + Math.random() * 360) % 360
                    });
                }
            }

            // Create new coin
            function createCoin() {
                // Find the current track segment at the top of the screen
                const topSegment = trackSegments.find(segment => segment.y < 0 && segment.y > -segmentHeight);
                if (topSegment) {
                    const trackX = canvas.width / 2 + topSegment.offset - trackWidth / 2;
                    const randomX = trackX + Math.random() * trackWidth;
                    
                    coinsArray.push({
                        x: randomX,
                        y: -coinSize,
                        size: coinSize,
                        collected: false,
                        rotation: 0,
                        hue: (hue + Math.random() * 360) % 360
                    });
                }
            }

            // Create new hyperfuel
            function createHyperfuel() {
                // Find the current track segment at the top of the screen
                const topSegment = trackSegments.find(segment => segment.y < 0 && segment.y > -segmentHeight);
                if (topSegment) {
                    const trackX = canvas.width / 2 + topSegment.offset - trackWidth / 2;
                    const randomX = trackX + Math.random() * trackWidth;
                    
                    hyperfuelArray.push({
                        x: randomX,
                        y: -hyperfuelSize,
                        size: hyperfuelSize,
                        collected: false,
                        rotation: 0,
                        hue: (hue + Math.random() * 360) % 360
                    });
                }
            }

            // Create new particle
            function createParticle() {
                if (particles.length < maxParticles) {
                    particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 2 + 1,
                        speed: Math.random() * 0.3 + 0.1,
                        hue: (hue + Math.random() * 60) % 360,
                        opacity: Math.random() * 0.2 + 0.05
                    });
                }
            }

            // Update particles
            function updateParticles() {
                particles.forEach(particle => {
                    particle.y += particle.speed;
                    particle.hue = (particle.hue + 0.2) % 360;
                    
                    if (particle.y > canvas.height) {
                        particle.y = -particle.size;
                        particle.x = Math.random() * canvas.width;
                    }
                });
            }

            // Draw particles
            function drawParticles() {
                ctx.shadowBlur = 3;
                particles.forEach(particle => {
                    ctx.fillStyle = `hsla(${particle.hue}, 100%, 70%, ${particle.opacity})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // Draw coins
            function drawCoins() {
                coinsArray.forEach(coin => {
                    if (coin.collected) return;
                    
                    coin.rotation += 0.1;
                    const scale = 1 + Math.sin(coin.rotation) * 0.2;
                    
                    ctx.save();
                    ctx.translate(coin.x, coin.y);
                    ctx.scale(scale, scale);
                    ctx.rotate(coin.rotation);
                    
                    // Draw coin with metallic gradient
                    const coinGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coin.size);
                    coinGradient.addColorStop(0, `hsl(${coin.hue}, 100%, 80%)`);
                    coinGradient.addColorStop(0.5, `hsl(${coin.hue}, 100%, 60%)`);
                    coinGradient.addColorStop(1, `hsl(${coin.hue}, 100%, 40%)`);
                    
                    ctx.fillStyle = coinGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, coin.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add coin glow
                    ctx.shadowColor = `hsl(${coin.hue}, 100%, 50%)`;
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = `hsl(${coin.hue}, 100%, 90%)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add coin details
                    ctx.beginPath();
                    ctx.arc(0, 0, coin.size * 0.6, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsl(${coin.hue}, 100%, 80%)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Add coin symbol
                    ctx.fillStyle = `hsl(${coin.hue}, 100%, 90%)`;
                    ctx.font = `${coin.size}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', 0, 0);
                    
                    ctx.restore();
                });
            }

            // Draw hyperfuel
            function drawHyperfuel() {
                hyperfuelArray.forEach(hyperfuelItem => {
                    if (hyperfuelItem.collected) return;
                    
                    hyperfuelItem.rotation += 0.1;
                    const scale = 1 + Math.sin(hyperfuelItem.rotation) * 0.2;
                    
                    ctx.save();
                    ctx.translate(hyperfuelItem.x, hyperfuelItem.y);
                    ctx.scale(scale, scale);
                    ctx.rotate(hyperfuelItem.rotation);
                    
                    // Draw hyperfuel with energy gradient
                    const hyperfuelGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, hyperfuelItem.size);
                    hyperfuelGradient.addColorStop(0, `hsl(${hyperfuelItem.hue}, 100%, 90%)`);
                    hyperfuelGradient.addColorStop(0.5, `hsl(${hyperfuelItem.hue}, 100%, 70%)`);
                    hyperfuelGradient.addColorStop(1, `hsl(${hyperfuelItem.hue}, 100%, 50%)`);
                    
                    ctx.fillStyle = hyperfuelGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, hyperfuelItem.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add hyperfuel glow
                    ctx.shadowColor = `hsl(${hyperfuelItem.hue}, 100%, 70%)`;
                    ctx.shadowBlur = 20;
                    ctx.strokeStyle = `hsl(${hyperfuelItem.hue}, 100%, 90%)`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Add hyperfuel details
                    ctx.beginPath();
                    ctx.arc(0, 0, hyperfuelItem.size * 0.6, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsl(${hyperfuelItem.hue}, 100%, 90%)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add hyperfuel symbol
                    ctx.fillStyle = `hsl(${hyperfuelItem.hue}, 100%, 100%)`;
                    ctx.font = `${hyperfuelItem.size}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('⚡', 0, 0);
                    
                    ctx.restore();
                });
            }

            // Draw hyperfuel gauge
            function drawHyperfuelGauge() {
                const gaugeWidth = 200;
                const gaugeHeight = 20;
                const gaugeX = 20;
                const gaugeY = 20;
                
                // Draw gauge background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
                
                // Draw hyperfuel level
                const hyperfuelWidth = (hyperfuel / maxHyperfuel) * gaugeWidth;
                const hyperfuelGradient = ctx.createLinearGradient(gaugeX, gaugeY, gaugeX + hyperfuelWidth, gaugeY);
                hyperfuelGradient.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
                hyperfuelGradient.addColorStop(1, `hsl(${(hue + 60) % 360}, 100%, 50%)`);
                
                ctx.fillStyle = hyperfuelGradient;
                ctx.fillRect(gaugeX, gaugeY, hyperfuelWidth, gaugeHeight);
                
                // Draw gauge border
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
                
                // Draw hyperfuel text
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.fillText(`Hyperfuel: ${Math.floor(hyperfuel)}%`, gaugeX + 10, gaugeY + 15);
            }

            // Update game state
            function update() {
                if (gameOver || isPaused) return;
                
                // Update screen shake with increased intensity
                if (isBoosting) {
                    screenShake.intensity = 15; // Increased from 5 to 15
                } else {
                    screenShake.intensity *= 0.9;
                }
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;

                // Apply screen shake to game container
                gameContainer.style.transform = `rotateX(${isBoosting ? 20 : 30}deg) rotateY(${tilt}deg) scale(${isBoosting ? 0.9 : 1}) translate(${screenShake.x}px, ${screenShake.y}px)`;

                // Update particles with reduced frequency
                updateParticles();
                if (Math.random() < 0.05) {
                    createParticle();
                }

                // Update coins
                coinsArray.forEach(coin => {
                    if (!coin.collected) {
                        coin.y += isBoosting ? 12 : 6;
                        coin.hue = (coin.hue + 1) % 360;
                        
                        // Check coin collection
                        if (Math.abs(car.x - coin.x) < (car.width/2 + coin.size) &&
                            Math.abs(car.y - coin.y) < (car.height/2 + coin.size)) {
                            coin.collected = true;
                            score += coinValue;
                            scoreElement.innerHTML = `Score: ${score}<br>Hyperfuel: ${Math.floor(hyperfuel)}%`;
                        }
                        
                        // Remove off-screen coins
                        if (coin.y > canvas.height) {
                            const index = coinsArray.indexOf(coin);
                            if (index > -1) {
                                coinsArray.splice(index, 1);
                            }
                        }
                    }
                });

                // Update hyperfuel
                hyperfuelArray.forEach(hyperfuelItem => {
                    if (!hyperfuelItem.collected) {
                        hyperfuelItem.y += isBoosting ? 12 : 6;
                        hyperfuelItem.hue = (hyperfuelItem.hue + 1) % 360;
                        
                        // Check hyperfuel collection
                        if (Math.abs(car.x - hyperfuelItem.x) < (car.width/2 + hyperfuelItem.size) &&
                            Math.abs(car.y - hyperfuelItem.y) < (car.height/2 + hyperfuelItem.size)) {
                            hyperfuelItem.collected = true;
                            hyperfuel = Math.min(maxHyperfuel, hyperfuel + hyperfuelValue);
                            score += hyperfuelValue;
                            scoreElement.innerHTML = `Score: ${score}<br>Hyperfuel: ${Math.floor(hyperfuel)}%`;
                        }
                        
                        // Remove off-screen hyperfuel
                        if (hyperfuelItem.y > canvas.height) {
                            const index = hyperfuelArray.indexOf(hyperfuelItem);
                            if (index > -1) {
                                hyperfuelArray.splice(index, 1);
                            }
                        }
                    }
                });

                // Handle hyperfuel consumption when boosting
                if (isBoosting && hyperfuel > 0) {
                    hyperfuel = Math.max(0, hyperfuel - 0.2); // Consume hyperfuel while boosting
                    if (hyperfuel <= 0) {
                        isBoosting = false;
                    }
                }

                // Update segment positions and properties
                trackSegments.forEach(segment => {
                    segment.y += isBoosting ? 12 : 6; // Double speed when boosting
                    segment.hue = (segment.hue + 0.8) % 360;
                    
                    // Update phase for smooth curve
                    segment.phase += 0.1;
                    const targetOffset = Math.sin(segment.phase) * 40;
                    
                    // Smooth transition to new offset
                    segment.offset += (targetOffset - segment.offset) * 0.1;
                    
                    // Reset segment position when it goes off screen
                    if (segment.y > canvas.height) {
                        segment.y = -segmentHeight;
                        segment.z = 0;
                        const lastSegment = trackSegments[trackSegments.length - 1];
                        segment.phase = lastSegment.phase + 0.1;
                        segment.offset = lastSegment.offset;
                        segment.hue = (lastSegment.hue + 30) % 360;
                    }
                });

                // Move obstacles
                obstacles.forEach(obstacle => {
                    obstacle.y += isBoosting ? 16 : 8; // Double speed when boosting
                    obstacle.z += isBoosting ? 1.2 : 0.6; // Double speed when boosting
                    obstacle.hue = (obstacle.hue + 1.5) % 360;
                });

                // Remove off-screen obstacles
                obstacles.forEach((obstacle, index) => {
                    if (obstacle.y > canvas.height) {
                        obstacles.splice(index, 1);
                        score += 10;
                        scoreElement.textContent = `Score: ${score}`;
                    }
                });

                // Create new obstacles more frequently
                if (Math.random() < 0.03) {
                    createObstacle();
                }

                // Create new coins
                if (Math.random() < 0.02) {
                    createCoin();
                }

                // Create new hyperfuel
                if (Math.random() < 0.01) {
                    createHyperfuel();
                }

                // Update container tilt based on car position and velocity
                const currentSegment = trackSegments.find(segment => 
                    segment.y <= car.y && segment.y + segmentHeight > car.y
                );
                
                if (currentSegment) {
                    const trackX = canvas.width / 2 + currentSegment.offset;
                    const targetTilt = ((car.x - trackX) / (trackWidth/2)) * 10;
                    const tiltDirection = car.velocity > 0 ? -1 : 1;
                    tilt += (targetTilt * tiltDirection - tilt) * 0.12;
                    gameContainer.style.transform = `rotateX(30deg) rotateY(${tilt}deg)`;
                }

                // Check collisions
                if (checkCollisions()) {
                    gameOver = true;
                    gameOverScreen.style.display = 'block';
                }
            }

            // Draw everything
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
                drawTrack();
                drawParticles();
                drawCoins();
                drawHyperfuel();
                drawObstacles();
                drawCar();
                drawHyperfuelGauge();

                // Add bright overlay when boosting
                if (isBoosting) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }

            // Draw psychedelic background
            function drawBackground() {
                hue = (hue + 0.3) % 360;
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                
                // Enhanced brightness when boosting
                if (isBoosting) {
                    gradient.addColorStop(0, `hsla(${hue}, 100%, 70%, 0.4)`);
                    gradient.addColorStop(0.5, `hsla(${(hue + 120) % 360}, 100%, 70%, 0.3)`);
                    gradient.addColorStop(1, `hsla(${(hue + 240) % 360}, 100%, 70%, 0.4)`);
                } else {
                    gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 0.3)`);
                    gradient.addColorStop(0.5, `hsla(${(hue + 120) % 360}, 100%, 50%, 0.2)`);
                    gradient.addColorStop(1, `hsla(${(hue + 240) % 360}, 100%, 50%, 0.3)`);
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw vaporwave grid
                const gridSize = 40;
                const gridColor = `hsla(${(hue + 180) % 360}, 100%, 50%, 0.1)`;
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1;

                // Draw vertical lines
                for (let x = 0; x < canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }

                // Draw horizontal lines
                for (let y = 0; y < canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                // Add perspective effect to grid
                ctx.save();
                ctx.translate(canvas.width/2, canvas.height/2);
                ctx.scale(1, 0.5);
                ctx.translate(-canvas.width/2, -canvas.height/2);
                
                // Draw diagonal lines for vaporwave effect
                const diagonalColor = `hsla(${(hue + 90) % 360}, 100%, 50%, 0.15)`;
                ctx.strokeStyle = diagonalColor;
                for (let i = -canvas.width; i < canvas.width * 2; i += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + canvas.height, canvas.height);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Draw track with 3D effect
            function drawTrack() {
                // Draw segments that are visible on screen
                trackSegments.forEach((segment, index) => {
                    const y = segment.y;
                    if (y < -segmentHeight || y > canvas.height) return;
                    
                    const x = canvas.width / 2 + segment.offset - trackWidth / 2;
                    const scale = 1 + (segment.z / 800);
                    const tilt = Math.sin(y / 100) * 3;
                    
                    ctx.save();
                    ctx.translate(x + trackWidth/2, y + segmentHeight/2);
                    ctx.scale(scale, scale);
                    ctx.rotate(tilt * Math.PI / 180);
                    ctx.translate(-(x + trackWidth/2), -(y + segmentHeight/2));
                    
                    // Draw track base with simplified gradient
                    const trackGradient = ctx.createLinearGradient(x, y, x, y + segmentHeight);
                    trackGradient.addColorStop(0, `hsla(${segment.hue}, 100%, 20%, 0.9)`);
                    trackGradient.addColorStop(0.5, `hsla(${(segment.hue + 60) % 360}, 100%, 30%, 0.9)`);
                    trackGradient.addColorStop(1, `hsla(${segment.hue}, 100%, 20%, 0.9)`);
                    ctx.fillStyle = trackGradient;
                    ctx.fillRect(x, y, trackWidth, segmentHeight);
                    
                    // Simplified track surface pattern
                    const patternSize = 30;
                    const patternColor = `hsla(${(segment.hue + 180) % 360}, 100%, 50%, 0.05)`;
                    ctx.strokeStyle = patternColor;
                    ctx.lineWidth = 1;
                    
                    // Draw diagonal pattern with reduced frequency
                    for (let i = -trackWidth; i < trackWidth * 2; i += patternSize * 2) {
                        ctx.beginPath();
                        ctx.moveTo(x + i, y);
                        ctx.lineTo(x + i + segmentHeight, y + segmentHeight);
                        ctx.stroke();
                    }
                    
                    // Draw track borders with simplified glow
                    ctx.shadowColor = `hsl(${segment.hue}, 100%, 50%)`;
                    ctx.shadowBlur = 10;
                    
                    // Left barrier with simplified gradient
                    const leftBarrierGradient = ctx.createLinearGradient(x, y, x + 20, y);
                    leftBarrierGradient.addColorStop(0, `hsla(${segment.hue}, 100%, 80%, 0.8)`);
                    leftBarrierGradient.addColorStop(1, `hsla(${segment.hue}, 100%, 50%, 0.4)`);
                    ctx.fillStyle = leftBarrierGradient;
                    ctx.fillRect(x, y, 20, segmentHeight);
                    
                    // Right barrier with simplified gradient
                    const rightBarrierGradient = ctx.createLinearGradient(x + trackWidth - 20, y, x + trackWidth, y);
                    rightBarrierGradient.addColorStop(0, `hsla(${segment.hue}, 100%, 50%, 0.4)`);
                    rightBarrierGradient.addColorStop(1, `hsla(${segment.hue}, 100%, 80%, 0.8)`);
                    ctx.fillStyle = rightBarrierGradient;
                    ctx.fillRect(x + trackWidth - 20, y, 20, segmentHeight);
                    
                    // Draw center line with simplified animation
                    const centerLineWidth = 4;
                    const centerLineOffset = Math.sin((y + trackOffset) / 30) * 5;
                    ctx.fillStyle = `hsl(${(segment.hue + 120) % 360}, 100%, 80%)`;
                    ctx.shadowColor = `hsl(${(segment.hue + 120) % 360}, 100%, 50%)`;
                    ctx.shadowBlur = 8;
                    ctx.fillRect(
                        x + trackWidth/2 - centerLineWidth/2 + centerLineOffset,
                        y,
                        centerLineWidth,
                        segmentHeight
                    );
                    
                    // Draw side lines with simplified animation
                    const sideLineWidth = 2;
                    const sideLineOffset = Math.sin((y + trackOffset) / 40) * 3;
                    ctx.fillStyle = `hsl(${(segment.hue + 180) % 360}, 100%, 80%)`;
                    ctx.shadowColor = `hsl(${(segment.hue + 180) % 360}, 100%, 50%)`;
                    ctx.shadowBlur = 5;
                    
                    // Left side line
                    ctx.fillRect(
                        x + trackWidth/4 - sideLineWidth/2 + sideLineOffset,
                        y,
                        sideLineWidth,
                        segmentHeight
                    );
                    
                    // Right side line
                    ctx.fillRect(
                        x + trackWidth*3/4 - sideLineWidth/2 - sideLineOffset,
                        y,
                        sideLineWidth,
                        segmentHeight
                    );
                    
                    ctx.restore();
                });
            }

            // Draw car with 3D effect
            function drawCar() {
                const scale = 1 + (car.z / 800);
                const tilt = Math.sin(Date.now() / 200) * 5;
                
                ctx.save();
                ctx.translate(car.x, car.y);
                ctx.scale(scale, scale);
                ctx.rotate((tilt + car.driftAngle) * Math.PI / 180);
                ctx.translate(-car.x, -car.y);
                
                // Main body with advanced gradient
                const carGradient = ctx.createLinearGradient(
                    car.x - car.width/2,
                    car.y - car.height/2,
                    car.x + car.width/2,
                    car.y + car.height/2
                );
                
                // Enhanced colors when boosting
                if (isBoosting) {
                    carGradient.addColorStop(0, `hsl(${hue}, 100%, 80%)`);
                    carGradient.addColorStop(0.3, `hsl(${(hue + 180) % 360}, 100%, 60%)`);
                    carGradient.addColorStop(0.7, `hsl(${(hue + 180) % 360}, 100%, 60%)`);
                    carGradient.addColorStop(1, `hsl(${hue}, 100%, 80%)`);
                } else {
                    carGradient.addColorStop(0, `hsl(${hue}, 100%, 60%)`);
                    carGradient.addColorStop(0.3, `hsl(${(hue + 180) % 360}, 100%, 40%)`);
                    carGradient.addColorStop(0.7, `hsl(${(hue + 180) % 360}, 100%, 40%)`);
                    carGradient.addColorStop(1, `hsl(${hue}, 100%, 60%)`);
                }
                
                // Draw car body with dynamic outline
                ctx.lineWidth = 3;
                ctx.strokeStyle = `hsl(${hue}, 100%, 90%)`;
                ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
                ctx.shadowBlur = 10;
                ctx.fillStyle = carGradient;
                
                // Draw main body
                ctx.beginPath();
                ctx.moveTo(car.x - car.width/2, car.y - car.height/3);
                ctx.lineTo(car.x - car.width/3, car.y - car.height/2);
                ctx.lineTo(car.x + car.width/3, car.y - car.height/2);
                ctx.lineTo(car.x + car.width/2, car.y - car.height/3);
                ctx.lineTo(car.x + car.width/2, car.y + car.height/3);
                ctx.lineTo(car.x + car.width/3, car.y + car.height/2);
                ctx.lineTo(car.x - car.width/3, car.y + car.height/2);
                ctx.lineTo(car.x - car.width/2, car.y + car.height/3);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Draw windows with dynamic outline
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.strokeStyle = `hsl(${(hue + 120) % 360}, 100%, 90%)`;
                ctx.shadowColor = `hsl(${(hue + 120) % 360}, 100%, 70%)`;
                ctx.beginPath();
                ctx.moveTo(car.x - car.width/3, car.y - car.height/3);
                ctx.lineTo(car.x + car.width/3, car.y - car.height/3);
                ctx.lineTo(car.x + car.width/4, car.y);
                ctx.lineTo(car.x - car.width/4, car.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Draw spoiler with dynamic outline
                ctx.fillStyle = carGradient;
                ctx.strokeStyle = `hsl(${(hue + 60) % 360}, 100%, 90%)`;
                ctx.shadowColor = `hsl(${(hue + 60) % 360}, 100%, 70%)`;
                ctx.beginPath();
                ctx.moveTo(car.x - car.width/2, car.y + car.height/3);
                ctx.lineTo(car.x - car.width/2, car.y + car.height/2);
                ctx.lineTo(car.x + car.width/2, car.y + car.height/2);
                ctx.lineTo(car.x + car.width/2, car.y + car.height/3);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Draw wheels with dynamic outline
                const wheelRadius = car.width/6;
                const wheelY = car.y + car.height/2;
                
                // Left wheel
                ctx.beginPath();
                ctx.arc(car.x - car.width/3, wheelY, wheelRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.strokeStyle = `hsl(${(hue + 180) % 360}, 100%, 90%)`;
                ctx.shadowColor = `hsl(${(hue + 180) % 360}, 100%, 70%)`;
                ctx.fill();
                ctx.stroke();
                
                // Right wheel
                ctx.beginPath();
                ctx.arc(car.x + car.width/3, wheelY, wheelRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Enhanced engine effects when boosting
                if (isBoosting) {
                    // Add boost trails
                    const trailGradient = ctx.createLinearGradient(
                        car.x - car.width/2, car.y + car.height/2,
                        car.x - car.width/2, car.y + car.height/2 + 40
                    );
                    trailGradient.addColorStop(0, `hsla(${(hue + 60) % 360}, 100%, 90%, 0.8)`);
                    trailGradient.addColorStop(1, `hsla(${(hue + 60) % 360}, 100%, 90%, 0)`);
                    
                    ctx.fillStyle = trailGradient;
                    ctx.beginPath();
                    ctx.moveTo(car.x - car.width/3, car.y + car.height/2);
                    ctx.lineTo(car.x + car.width/3, car.y + car.height/2);
                    ctx.lineTo(car.x, car.y + car.height/2 + 40);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add boost particles
                    for (let i = 0; i < 5; i++) {
                        const particleX = car.x + (Math.random() - 0.5) * car.width;
                        const particleY = car.y + car.height/2 + Math.random() * 30;
                        const particleSize = Math.random() * 4 + 2;
                        
                        ctx.fillStyle = `hsla(${(hue + 60) % 360}, 100%, 90%, ${Math.random() * 0.5 + 0.5})`;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            }

            // Draw obstacles with 3D effect
            function drawObstacles() {
                obstacles.forEach(obstacle => {
                    const scale = 1 + (obstacle.z / 800);
                    const tilt = Math.sin(Date.now() / 300 + obstacle.x) * 5;
                    
                    ctx.save();
                    ctx.translate(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
                    ctx.scale(scale, scale);
                    ctx.rotate(tilt * Math.PI / 180);
                    ctx.translate(-(obstacle.x + obstacle.width/2), -(obstacle.y + obstacle.height/2));
                    
                    // Draw building base with gradient
                    const buildingGradient = ctx.createLinearGradient(
                        obstacle.x,
                        obstacle.y,
                        obstacle.x,
                        obstacle.y + obstacle.height
                    );
                    buildingGradient.addColorStop(0, `hsl(${obstacle.hue}, 100%, 30%)`);
                    buildingGradient.addColorStop(0.5, `hsl(${(obstacle.hue + 60) % 360}, 100%, 20%)`);
                    buildingGradient.addColorStop(1, `hsl(${obstacle.hue}, 100%, 10%)`);
                    ctx.fillStyle = buildingGradient;
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Add building details
                    const windowSize = 8;
                    const windowSpacing = 12;
                    const windowRows = Math.floor(obstacle.height / windowSpacing);
                    const windowCols = Math.floor(obstacle.width / windowSpacing);
                    
                    // Draw windows
                    for (let row = 0; row < windowRows; row++) {
                        for (let col = 0; col < windowCols; col++) {
                            const windowX = obstacle.x + col * windowSpacing + (windowSpacing - windowSize) / 2;
                            const windowY = obstacle.y + row * windowSpacing + (windowSpacing - windowSize) / 2;
                            
                            // Random window glow
                            const glowIntensity = Math.random() * 0.8 + 0.2;
                            ctx.fillStyle = `hsla(${(obstacle.hue + 120) % 360}, 100%, 70%, ${glowIntensity})`;
                            ctx.shadowColor = `hsla(${(obstacle.hue + 120) % 360}, 100%, 50%, ${glowIntensity})`;
                            ctx.shadowBlur = 5;
                            ctx.fillRect(windowX, windowY, windowSize, windowSize);
                        }
                    }
                    
                    // Add building edges with glow
                    ctx.shadowColor = `hsl(${obstacle.hue}, 100%, 50%)`;
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = `hsl(${obstacle.hue}, 100%, 70%)`;
                    ctx.lineWidth = 2;
                    
                    // Draw vertical edges
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x, obstacle.y);
                    ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
                    ctx.moveTo(obstacle.x + obstacle.width, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                    ctx.stroke();
                    
                    // Draw horizontal edges
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y);
                    ctx.moveTo(obstacle.x, obstacle.y + obstacle.height);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                    ctx.stroke();
                    
                    // Add architectural details
                    const detailSpacing = obstacle.height / 4;
                    for (let i = 1; i < 4; i++) {
                        const detailY = obstacle.y + i * detailSpacing;
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x, detailY);
                        ctx.lineTo(obstacle.x + obstacle.width, detailY);
                        ctx.strokeStyle = `hsla(${(obstacle.hue + 180) % 360}, 100%, 50%, 0.5)`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    
                    // Add antenna/spire
                    const spireHeight = obstacle.height * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width/2, obstacle.y - spireHeight);
                    ctx.strokeStyle = `hsl(${(obstacle.hue + 60) % 360}, 100%, 70%)`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add spire glow
                    ctx.fillStyle = `hsl(${(obstacle.hue + 60) % 360}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.arc(obstacle.x + obstacle.width/2, obstacle.y - spireHeight, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                });
            }

            // Check collisions
            function checkCollisions() {
                // Check track boundaries
                const currentSegment = trackSegments.find(segment => 
                    segment.y <= car.y && segment.y + segmentHeight > car.y
                );
                
                if (currentSegment) {
                    const trackX = canvas.width / 2 + currentSegment.offset;
                    const trackLeft = trackX - trackWidth/2;
                    const trackRight = trackX + trackWidth/2;
                    
                    // Check left barrier collision
                    if (car.x - car.width/2 < trackLeft + 20) {
                        car.x = trackLeft + 20 + car.width/2;
                        car.velocity = -car.velocity * 0.5; // Bounce off with reduced velocity
                        return false;
                    }
                    
                    // Check right barrier collision
                    if (car.x + car.width/2 > trackRight - 20) {
                        car.x = trackRight - 20 - car.width/2;
                        car.velocity = -car.velocity * 0.5; // Bounce off with reduced velocity
                        return false;
                    }
                }

                // Check obstacle collisions
                return obstacles.some(obstacle => {
                    return car.x + car.width / 2 > obstacle.x &&
                           car.x - car.width / 2 < obstacle.x + obstacle.width &&
                           car.y + car.height / 2 > obstacle.y &&
                           car.y - car.height / 2 < obstacle.y + obstacle.height;
                });
            }

            // Game loop
            function gameLoop() {
                if (!isPaused) {
                    update();
                }
                draw();
                animationFrame = requestAnimationFrame(gameLoop);
            }

            // Handle keyboard input
            const keys = {};
            window.addEventListener('keydown', e => {
                keys[e.key] = true;
                if (gameOver && e.key === 'r') {
                    resetGame();
                }
                if (e.key === 'Escape' && gameStarted && !gameOver) {
                    togglePause();
                }
            });
            window.addEventListener('keyup', e => {
                keys[e.key] = false;
            });

            // Update car position based on input
            function handleInput() {
                const baseMaxVelocity = 15;
                const boostMultiplier = 2.5;
                const maxVelocity = isBoosting ? baseMaxVelocity * boostMultiplier : baseMaxVelocity;
                const acceleration = isBoosting ? 1.2 : 0.6;
                const deceleration = isBoosting ? 0.8 : 0.4;
                const driftThreshold = 1.0;
                const maxDriftAngle = 25;
                const trackFollowSpeed = 0.08;

                // Handle boost input
                if ((keys['Shift'] || keys[' ']) && hyperfuel > 0) {
                    isBoosting = true;
                    // Only change scale and angle during boost
                    gameContainer.style.transform = `rotateX(20deg) rotateY(${tilt}deg) scale(0.9)`;
                } else {
                    isBoosting = false;
                    // Return to normal scale and angle
                    gameContainer.style.transform = `rotateX(30deg) rotateY(${tilt}deg) scale(1)`;
                }

                // Find the current track segment the car is on
                const currentSegment = trackSegments.find(segment => 
                    segment.y <= car.y && segment.y + segmentHeight > car.y
                );

                if (currentSegment) {
                    // Calculate the target position based on track offset
                    const targetX = canvas.width / 2 + currentSegment.offset;
                    
                    // Handle left/right movement with track following
                    if (keys['ArrowLeft'] || keys['a']) {
                        car.velocity = Math.max(-maxVelocity, car.velocity - acceleration);
                        if (Math.abs(car.velocity) > driftThreshold) {
                            car.drift = true;
                            car.driftAngle = Math.min(maxDriftAngle, car.driftAngle + 2);
                        }
                    } else if (keys['ArrowRight'] || keys['d']) {
                        car.velocity = Math.min(maxVelocity, car.velocity + acceleration);
                        if (Math.abs(car.velocity) > driftThreshold) {
                            car.drift = true;
                            car.driftAngle = Math.max(-maxDriftAngle, car.driftAngle - 2);
                        }
                    } else {
                        // Decelerate when no input
                        if (car.velocity > 0) {
                            car.velocity = Math.max(0, car.velocity - deceleration);
                        } else if (car.velocity < 0) {
                            car.velocity = Math.min(0, car.velocity + deceleration);
                        }
                        
                        // Reduce drift angle when not actively drifting
                        if (Math.abs(car.driftAngle) > 0) {
                            car.driftAngle *= 0.95;
                            if (Math.abs(car.driftAngle) < 0.1) {
                                car.driftAngle = 0;
                                car.drift = false;
                            }
                        }
                    }

                    // Update car position with momentum and track following
                    const trackLeft = targetX - trackWidth/2 + car.width/2;
                    const trackRight = targetX + trackWidth/2 - car.width/2;
                    
                    // Apply velocity with full effect
                    car.x += car.velocity;
                    
                    // Keep car within track boundaries
                    car.x = Math.max(trackLeft, Math.min(trackRight, car.x));
                }
            }

            // Toggle pause state
            function togglePause() {
                isPaused = !isPaused;
                if (isPaused) {
                    pauseMenu.style.display = 'block';
                    canvas.classList.add('blur');
                } else {
                    pauseMenu.style.display = 'none';
                    canvas.classList.remove('blur');
                }
            }

            // Resume button click handler
            resumeButton.addEventListener('click', () => {
                togglePause();
            });

            // Reset game
            function resetGame() {
                gameOver = false;
                isPaused = false;
                score = 0;
                hyperfuel = 100;
                isBoosting = false;
                scoreElement.innerHTML = `Score: ${score}<br>Hyperfuel: ${Math.floor(hyperfuel)}%`;
                gameOverScreen.style.display = 'none';
                pauseMenu.style.display = 'none';
                canvas.classList.remove('blur');
                car.x = canvas.width / 2;
                obstacles.length = 0;
                coinsArray.length = 0;
                hyperfuelArray.length = 0;
                particles.length = 0;
                trackSegments.length = 0;
                initTrack();
            }

            // Start game
            startButton.addEventListener('click', () => {
                gameStarted = true;
                startScreen.style.display = 'none';
                initTrack();
                gameLoop();
            });

            // Main game loop with input handling
            function mainLoop() {
                if (gameStarted && !gameOver) {
                    handleInput();
                }
                requestAnimationFrame(mainLoop);
            }

            // Initialize the game
            initTrack();
            draw();
            mainLoop();
        });
    </script>
</body>
</html> 